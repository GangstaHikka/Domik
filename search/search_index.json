{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"Untitled/","text":"","title":"Untitled"},{"location":"Documentation/Floor/","text":"","title":"Floor"},{"location":"Documentation/Interior/","text":"Interior \u00b6 To create new floor select some folder in the Project window -> Right Mouse Click -> Create -> Domik -> Interior Interior Settings \u00b6 Furniture - here you can define a set of furniture or some other placeable objects which can be in rooms with this interior. Skins - a set of skins for rooms with this interior. These skins have higher priority than House Generator skins, so you can use them for define more specific cases like room walls, floors, furniture look , etc. Placing Rules \u00b6 this panel defines special rules for interior placing. Max Count Per Floor - Use it if you want to limit numbers of this interior on the floor. Example: you need maximum two bedrooms per floor because... why someone needs more? O.o Prefer Room - which size of room better for this interior? - Small - prefer small rooms - Middle - prefer regular rooms - Big - prefer big rooms - Random - you don't care Parts Limit \u00b6 Here you defines necessary and forbidden parts of the house. lets add something: mode: - Fixed - only this number of part is acceptable - Range - only this range of part's count is acceptable - At least one - there should be at least one instance of this part - Unacceptable - rooms with this part will be ignored","title":"Interior"},{"location":"Documentation/Interior/#interior","text":"To create new floor select some folder in the Project window -> Right Mouse Click -> Create -> Domik -> Interior","title":"Interior"},{"location":"Documentation/Interior/#interior-settings","text":"Furniture - here you can define a set of furniture or some other placeable objects which can be in rooms with this interior. Skins - a set of skins for rooms with this interior. These skins have higher priority than House Generator skins, so you can use them for define more specific cases like room walls, floors, furniture look , etc.","title":"Interior Settings"},{"location":"Documentation/Interior/#placing-rules","text":"this panel defines special rules for interior placing. Max Count Per Floor - Use it if you want to limit numbers of this interior on the floor. Example: you need maximum two bedrooms per floor because... why someone needs more? O.o Prefer Room - which size of room better for this interior? - Small - prefer small rooms - Middle - prefer regular rooms - Big - prefer big rooms - Random - you don't care","title":"Placing Rules"},{"location":"Documentation/Interior/#parts-limit","text":"Here you defines necessary and forbidden parts of the house. lets add something: mode: - Fixed - only this number of part is acceptable - Range - only this range of part's count is acceptable - At least one - there should be at least one instance of this part - Unacceptable - rooms with this part will be ignored","title":"Parts Limit"},{"location":"Documentation/Mask/","text":"Mask \u00b6 The Mask - is a mask of adjacency of cells . This is a description of some place, but in terms of accessibility from the target cell . Mostly useful in situations when you want to find borders of rooms or whole house. How to create a mask? To create new floor select some folder in the Project window -> Right Mouse Click -> Create -> Domik -> Mask Space - what type of accessibility do you want to check? House - you want to check that the neighbouring cells belong to the house (you want to find borders of house). Rooms - you want to check that the neighbouring cells belong to target cell's room (you want to find borders of room). Floor - a floor where you want to edit cells to check. To start working with cells select some cell in the grid. State - select what you expect from this cell: Not Important - you don't want to check this cell. Accessible - This cell should be belonged to the same room as a target cell if you selected the Rooms space or this cell should be belonged to the house if you selected the House space . Inaccessible - this cell should be belonged to another room or doesn't exist at all if you selected the Room space or this cell shouldn't exist in this house if you selected the House space . You can see changes of mask by the preview system .","title":"**Mask**"},{"location":"Documentation/Mask/#mask","text":"The Mask - is a mask of adjacency of cells . This is a description of some place, but in terms of accessibility from the target cell . Mostly useful in situations when you want to find borders of rooms or whole house. How to create a mask? To create new floor select some folder in the Project window -> Right Mouse Click -> Create -> Domik -> Mask Space - what type of accessibility do you want to check? House - you want to check that the neighbouring cells belong to the house (you want to find borders of house). Rooms - you want to check that the neighbouring cells belong to target cell's room (you want to find borders of room). Floor - a floor where you want to edit cells to check. To start working with cells select some cell in the grid. State - select what you expect from this cell: Not Important - you don't want to check this cell. Accessible - This cell should be belonged to the same room as a target cell if you selected the Rooms space or this cell should be belonged to the house if you selected the House space . Inaccessible - this cell should be belonged to another room or doesn't exist at all if you selected the Room space or this cell shouldn't exist in this house if you selected the House space . You can see changes of mask by the preview system .","title":"Mask"},{"location":"Documentation/Palette/","text":"Palette","title":"Palette"},{"location":"Documentation/Part/","text":"Part \u00b6 The Part - is a scriptable object which represents an abstract idea of some house object. It's just the name of something that you expect to see in the house, nothing more. The pipeline works only with parts and knows nothing about how parts actually look. A look of the part defines in the skin Part with rotations Rotation degrees written in square brackets Part without rotations Rotation degrees written in square brackets Turned 90 - link to the same part but rotated by 90 degrees. Turned 180 - link to the same part but rotated by 180 degrees. Turned 270 - link to the same part but rotated by 270 degrees. See Also: how the domik builds a house , how to add new stuff , deep dive into house building process .","title":"**Part**"},{"location":"Documentation/Part/#part","text":"The Part - is a scriptable object which represents an abstract idea of some house object. It's just the name of something that you expect to see in the house, nothing more. The pipeline works only with parts and knows nothing about how parts actually look. A look of the part defines in the skin Part with rotations Rotation degrees written in square brackets Part without rotations Rotation degrees written in square brackets Turned 90 - link to the same part but rotated by 90 degrees. Turned 180 - link to the same part but rotated by 180 degrees. Turned 270 - link to the same part but rotated by 270 degrees. See Also: how the domik builds a house , how to add new stuff , deep dive into house building process .","title":"Part"},{"location":"Documentation/Pipeline/","text":"Pipeline \u00b6 The Pipeline is a visual scripting language which uses to generate a house. To create a new instance of Pipeline right click on some folder -> Create -> Domik -> Pipeline. To open some existed Pipeline just double click to it. In pipeline you describes a process of house generation step-by-step. The pipeline consists of nodes. Every node is a step of generation of house. In most cases typical node has two pines: - In - Input cells. - Out - output cells. Node get cells from Input, process them and returns to Output. Sometimes it contains parameters. Every pipeline instance should have at least two nodes: Start Node and End Node. Start Node gets an info from House Generator OLD and constructs raw cells. End Node returns processed nodes to the House Builder. Here is an example of primitive pipeline. Start Node - creates a set of nodes based an info from House Generator OLD . Add Parts Node - adds Floor part and Ceiling part to all cells from input. End node - returns input cells with floors and ceilings to the House Builder. To get more information about possible nodes read nodes description below:","title":"**Pipeline**"},{"location":"Documentation/Pipeline/#pipeline","text":"The Pipeline is a visual scripting language which uses to generate a house. To create a new instance of Pipeline right click on some folder -> Create -> Domik -> Pipeline. To open some existed Pipeline just double click to it. In pipeline you describes a process of house generation step-by-step. The pipeline consists of nodes. Every node is a step of generation of house. In most cases typical node has two pines: - In - Input cells. - Out - output cells. Node get cells from Input, process them and returns to Output. Sometimes it contains parameters. Every pipeline instance should have at least two nodes: Start Node and End Node. Start Node gets an info from House Generator OLD and constructs raw cells. End Node returns processed nodes to the House Builder. Here is an example of primitive pipeline. Start Node - creates a set of nodes based an info from House Generator OLD . Add Parts Node - adds Floor part and Ceiling part to all cells from input. End node - returns input cells with floors and ceilings to the House Builder. To get more information about possible nodes read nodes description below:","title":"Pipeline"},{"location":"Documentation/Place/","text":"Place \u00b6 To create new floor select some folder in the Project window -> Right Mouse Click -> Create -> Domik -> Place Place is a description of some... place :D Basically it's a small 3x3x3 grid with parts. Filter node or Placing System will use it to filter cells with identical environment. So you can use it to define where you want to place some Placeable Object or you can use it to filter cells in the Pipeline. Parts \u00b6 Floor - select floor which cells you want to edit. Cells Grid \u00b6 Here is a grid of cells which represent some place. Click on some cell to start working with it. Enable - set true if you want to check this cell in filtration progress. Parts List - add here all parts which you expect to see in this cell. !Note: disabled cell and enabled cell but without parts are not equal! If you enable some cell but didn't add parts means that you expect that this cell will be totally empty.","title":"Place"},{"location":"Documentation/Place/#place","text":"To create new floor select some folder in the Project window -> Right Mouse Click -> Create -> Domik -> Place Place is a description of some... place :D Basically it's a small 3x3x3 grid with parts. Filter node or Placing System will use it to filter cells with identical environment. So you can use it to define where you want to place some Placeable Object or you can use it to filter cells in the Pipeline.","title":"Place"},{"location":"Documentation/Place/#parts","text":"Floor - select floor which cells you want to edit.","title":"Parts"},{"location":"Documentation/Place/#cells-grid","text":"Here is a grid of cells which represent some place. Click on some cell to start working with it. Enable - set true if you want to check this cell in filtration progress. Parts List - add here all parts which you expect to see in this cell. !Note: disabled cell and enabled cell but without parts are not equal! If you enable some cell but didn't add parts means that you expect that this cell will be totally empty.","title":"Cells Grid"},{"location":"Documentation/Skin/","text":"Skin \u00b6 The Skin is a bridge between part s and theirs in-game representations. From the Domik perspective, the house is a structured collection of parts , so it has to convert these parts into real game objects . And the Skin helps the Domik to understand how parts should look like. The Skin is a prefab with a Skin component and a bunch of child game objects with Part Builder components. It also contains a list of bindings between parts and part builders . Settings \u00b6 Cell Width - width and length sizes of the cell. Just write a floor mesh width here (in meters). Cell Height - height of the cell. Just write a wall mesh height here (in meters). Binding \u00b6 Binding list is a list of binding between part and part builders . Create Parts for unbound? - set it true if you want to create new parts for unbound part builders in the process of binding update. Path field - where you want to create new parts? Change Folder button - click to change a folder for new parts . Update Binding button - click it to update a list of bindings. Binds list - a list of binding between parts and part builders . Binds list element \u00b6 Part Builder field - a part builder for the part . Part Builder - a part that you want to build by this part builder . Number field - a rotation offset after building. See also: how to add new stuff , part , part builder , house generator .","title":"**Skin**"},{"location":"Documentation/Skin/#skin","text":"The Skin is a bridge between part s and theirs in-game representations. From the Domik perspective, the house is a structured collection of parts , so it has to convert these parts into real game objects . And the Skin helps the Domik to understand how parts should look like. The Skin is a prefab with a Skin component and a bunch of child game objects with Part Builder components. It also contains a list of bindings between parts and part builders .","title":"Skin"},{"location":"Documentation/Skin/#settings","text":"Cell Width - width and length sizes of the cell. Just write a floor mesh width here (in meters). Cell Height - height of the cell. Just write a wall mesh height here (in meters).","title":"Settings"},{"location":"Documentation/Skin/#binding","text":"Binding list is a list of binding between part and part builders . Create Parts for unbound? - set it true if you want to create new parts for unbound part builders in the process of binding update. Path field - where you want to create new parts? Change Folder button - click to change a folder for new parts . Update Binding button - click it to update a list of bindings. Binds list - a list of binding between parts and part builders .","title":"Binding"},{"location":"Documentation/Skin/#binds-list-element","text":"Part Builder field - a part builder for the part . Part Builder - a part that you want to build by this part builder . Number field - a rotation offset after building. See also: how to add new stuff , part , part builder , house generator .","title":"Binds list element"},{"location":"Documentation/deep-dive-into-house-building-process/","text":"Deep dive into house building process \u00b6 The process of house generation works in three steps: Generating of house cells Extracting a house build data from cells Building a house from an extracted house build data 1. Generating house cells . \u00b6 This step provides by the Pipeline - a visual scripting system. From the Pipeline perspective there is no 3D meshes, materials, textures etc. The Pipeline works with an abstract idea of parts of the house. And the name of this abstract thing is... The Part ! Pretty obvious :D That is the Part? \u00b6 The part is a scriptable object with name and references to 3 other parts with rotations by 90 , 180 and 270 degrees. Some parts have no rotations (example: floor, ceiling, round table...) so rotated parts references will be empty and that's fine. Part without rotations The most important aspect of the part is its name . The part's name is all that the Pipeline should know to start working with it. You can even have two parts with different GUID but with the same name and the Pipeline will think that they are equals. The Pipeline has only one target - create cells. That are Cells? \u00b6 Cells is an abstract representation of house in the code. To understand the conception, just image a house as a 3D grid of cells. (\u256e\u00b0-\u00b0)\u256e\u2533\u2501\u2501\u2533 ( \u256f\u00b0\u25a1\u00b0)\u256f \u253b\u2501\u2501\u253b Each cell contains a floor, ceiling, walls and something else. Floor, ceiling and walls are parts . So yeah, cells is just a 3D grid of parts lists. Representation in code Cells Cell In the pipeline you create cells, modify them, remove, merge and so on. And in the end you return the result in the end node. Created cells comes to the second step of the generation - extracting a house build data from cells. 2. Extracting a house build data from cells . \u00b6 The Build Data Extractor transforms cells from an abstract representation of house to the house building instruction. It sorts cells to floors and rooms and finds part's builder for all cell's parts . Part Builders are stored in skins , so the Build Data Extractor asks them if they have something to build some part . If there is no Part Builder for some part , this part will be ignored during house building. The priority of skins asking from highest to lowest: Skins Layer Interior Skins House Skins Skins Layer Interior Skins House Skins You can change a look of the room by changing interior skins because they have higher priority than house skins . The Skins Layer has been created for special cases when you want to change a look of some cells filtered by special rules in the Pipeline . So in the result it returns a structured collection of Part Builders - a House Build Data . Representation in code Floors Floor Room Cell 3. Building of the house by the house build data. \u00b6 The House Builder takes a house build data and just build it! It's more complicated, actually, but there is no reason to dive so deep. But why so complicated? \u00b6 Well, there is only one reason - flexibility. If you are a programmer, you may know the conception of model-view splitting. The Part is a model and the Part Builder is a view. Part is an abstract idea of something, and the Part Builder builds a look of it. Thanks to this separation, we can redefine how a cell should look right on the fly. For example, you created some pipeline which generates a simple village house. And you have a regular village where you want to place it. But then you want to add a village which was corrupted by chaos, with lakes of blood, rusted chains and so on. But you have this innocent, vibrant, happy house! That's not that you want. Thanks to this separation, you just need to edit skins to change a view of house. You don't need to touch the Pipeline at all. And that's wonderful.","title":"**Deep dive into house building process**"},{"location":"Documentation/deep-dive-into-house-building-process/#deep-dive-into-house-building-process","text":"The process of house generation works in three steps: Generating of house cells Extracting a house build data from cells Building a house from an extracted house build data","title":"Deep dive into house building process"},{"location":"Documentation/deep-dive-into-house-building-process/#1-generating-house-cells","text":"This step provides by the Pipeline - a visual scripting system. From the Pipeline perspective there is no 3D meshes, materials, textures etc. The Pipeline works with an abstract idea of parts of the house. And the name of this abstract thing is... The Part ! Pretty obvious :D","title":"1. Generating house cells."},{"location":"Documentation/deep-dive-into-house-building-process/#that-is-the-part","text":"The part is a scriptable object with name and references to 3 other parts with rotations by 90 , 180 and 270 degrees. Some parts have no rotations (example: floor, ceiling, round table...) so rotated parts references will be empty and that's fine. Part without rotations The most important aspect of the part is its name . The part's name is all that the Pipeline should know to start working with it. You can even have two parts with different GUID but with the same name and the Pipeline will think that they are equals. The Pipeline has only one target - create cells.","title":"That is the Part?"},{"location":"Documentation/deep-dive-into-house-building-process/#that-are-cells","text":"Cells is an abstract representation of house in the code. To understand the conception, just image a house as a 3D grid of cells. (\u256e\u00b0-\u00b0)\u256e\u2533\u2501\u2501\u2533 ( \u256f\u00b0\u25a1\u00b0)\u256f \u253b\u2501\u2501\u253b Each cell contains a floor, ceiling, walls and something else. Floor, ceiling and walls are parts . So yeah, cells is just a 3D grid of parts lists. Representation in code Cells Cell In the pipeline you create cells, modify them, remove, merge and so on. And in the end you return the result in the end node. Created cells comes to the second step of the generation - extracting a house build data from cells.","title":"That are Cells?"},{"location":"Documentation/deep-dive-into-house-building-process/#2-extracting-a-house-build-data-from-cells","text":"The Build Data Extractor transforms cells from an abstract representation of house to the house building instruction. It sorts cells to floors and rooms and finds part's builder for all cell's parts . Part Builders are stored in skins , so the Build Data Extractor asks them if they have something to build some part . If there is no Part Builder for some part , this part will be ignored during house building. The priority of skins asking from highest to lowest: Skins Layer Interior Skins House Skins Skins Layer Interior Skins House Skins You can change a look of the room by changing interior skins because they have higher priority than house skins . The Skins Layer has been created for special cases when you want to change a look of some cells filtered by special rules in the Pipeline . So in the result it returns a structured collection of Part Builders - a House Build Data . Representation in code Floors Floor Room Cell","title":"2. Extracting a house build data from cells."},{"location":"Documentation/deep-dive-into-house-building-process/#3-building-of-the-house-by-the-house-build-data","text":"The House Builder takes a house build data and just build it! It's more complicated, actually, but there is no reason to dive so deep.","title":"3. Building of the house by the house build data."},{"location":"Documentation/deep-dive-into-house-building-process/#but-why-so-complicated","text":"Well, there is only one reason - flexibility. If you are a programmer, you may know the conception of model-view splitting. The Part is a model and the Part Builder is a view. Part is an abstract idea of something, and the Part Builder builds a look of it. Thanks to this separation, we can redefine how a cell should look right on the fly. For example, you created some pipeline which generates a simple village house. And you have a regular village where you want to place it. But then you want to add a village which was corrupted by chaos, with lakes of blood, rusted chains and so on. But you have this innocent, vibrant, happy house! That's not that you want. Thanks to this separation, you just need to edit skins to change a view of house. You don't need to touch the Pipeline at all. And that's wonderful.","title":"But why so complicated?"},{"location":"Documentation/facades-workflow/","text":"Facades workflow \u00b6 The look of facades is controlling by two systems: Skin system Floor Tag system Here is the next idea: you define a look of the house facade by skins, and then you select suitable skins for each floor in the Pipeline by floor tags. Facade of the house that we use in these examples is separated to five skins - thin facade, regular facade, thick facade, columns and plinth Change facades by floor tags \u00b6 This method provides by the pipeline . To use it, just select some floor and change its floor tag . It works because an example pipeline includes special logic. Here, cells of floors with facade tags will be filtered and processed to achieve the final result. You can create other tags and generation steps to make things different. Read more: floor tag Change facades by house skins \u00b6 Select the House Generator on the scene and look at the House Skins panel. Here is already added a random container for facade palettes. We have to add new skin in top of this skins list to override the house facade. A facade of the house is separated into five skins, but in this tutorial we will change only one - Facade Regular skin . To do it we have to duplicate this skin and edit it. We can just change this skin as it shows in the how to change room walls article too. Go to the Domik folder -> House Example -> Skins -> Facade Walls Regular , duplicate some skin and open it. Now replace materials with something other. Exit with saving, drag-n-drop this skin in top of the House Generator skins list and regenerate the house to check out the result. You can also change meshes of walls or add something new. Let's make this wall even worse to add new window frames.","title":"**Facades workflow**"},{"location":"Documentation/facades-workflow/#facades-workflow","text":"The look of facades is controlling by two systems: Skin system Floor Tag system Here is the next idea: you define a look of the house facade by skins, and then you select suitable skins for each floor in the Pipeline by floor tags. Facade of the house that we use in these examples is separated to five skins - thin facade, regular facade, thick facade, columns and plinth","title":"Facades workflow"},{"location":"Documentation/facades-workflow/#change-facades-by-floor-tags","text":"This method provides by the pipeline . To use it, just select some floor and change its floor tag . It works because an example pipeline includes special logic. Here, cells of floors with facade tags will be filtered and processed to achieve the final result. You can create other tags and generation steps to make things different. Read more: floor tag","title":"Change facades by floor tags"},{"location":"Documentation/facades-workflow/#change-facades-by-house-skins","text":"Select the House Generator on the scene and look at the House Skins panel. Here is already added a random container for facade palettes. We have to add new skin in top of this skins list to override the house facade. A facade of the house is separated into five skins, but in this tutorial we will change only one - Facade Regular skin . To do it we have to duplicate this skin and edit it. We can just change this skin as it shows in the how to change room walls article too. Go to the Domik folder -> House Example -> Skins -> Facade Walls Regular , duplicate some skin and open it. Now replace materials with something other. Exit with saving, drag-n-drop this skin in top of the House Generator skins list and regenerate the house to check out the result. You can also change meshes of walls or add something new. Let's make this wall even worse to add new window frames.","title":"Change facades by house skins"},{"location":"Documentation/floor-tag/","text":"Floor Tag \u00b6 Tag is a marking system which you can use to separate some cells from others. To create a tag right click on some folder -> Create -> Domik -> Tag. See also: - House Generator OLD -> Floors -> Tags - Filter By Tag node","title":"**Floor Tag**"},{"location":"Documentation/floor-tag/#floor-tag","text":"Tag is a marking system which you can use to separate some cells from others. To create a tag right click on some folder -> Create -> Domik -> Tag. See also: - House Generator OLD -> Floors -> Tags - Filter By Tag node","title":"Floor Tag"},{"location":"Documentation/getting-started/","text":"Getting Started \u00b6 This is a Domik - a tool for houses creation. It uses a visual scripting system to determine a logic of generation and designed to work with modular building systems. Highlights \u00b6 Generation of room interiors with furniture . Powerful visual scripting system - the Pipeline . Supports of third party assets. Seed number based generation, feel free to integrate it with your own procedural worlds. Supports of all types of gameobjects , so you can place something like a spawn-point right in a house. Just use a furniture system . In-Editor Generation. Runtime Generation. Multiple floors . Stairs . Mesh combine system is built-in. 2D Assets support (example is not included yet). Mobile , Consoles , WebGL and PC are supported. HDRP , URP and Built-in scriptable pipeline are supported. Tutorials \u00b6 how to create a procedural house how to change a house size how to change house floors how the domik builds a house how to change room walls how to replace models or materials how to add new stuff how to create and use a placeable object facades workflow how to create a preview system deep dive into house building process Main Concepts \u00b6 house generator preview system part part builder skin palette palettes random container place mask placeable object placeable objects container floor interior floor tag pipeline Pipeline Nodes \u00b6 Action: extract positions find and replace shift Add: add part Filter: filter by mask filter by positions filter by tag filter floor filter internal doors places filter intersections filter neighbor cells filter random cells filter random input filter with part filter with parts filter without part Flow: exclude merge override shuffle Interiors: calculate room interiors place furniture return interiors split into rooms Main: end start Place: place part by mask for all rotations place placeable object forced place placeable object place stairs Remove: apply parts removing remove part remove part later Skins: create skins layer override skins layer return skins layer","title":"**Getting Started**"},{"location":"Documentation/getting-started/#getting-started","text":"This is a Domik - a tool for houses creation. It uses a visual scripting system to determine a logic of generation and designed to work with modular building systems.","title":"Getting Started"},{"location":"Documentation/getting-started/#highlights","text":"Generation of room interiors with furniture . Powerful visual scripting system - the Pipeline . Supports of third party assets. Seed number based generation, feel free to integrate it with your own procedural worlds. Supports of all types of gameobjects , so you can place something like a spawn-point right in a house. Just use a furniture system . In-Editor Generation. Runtime Generation. Multiple floors . Stairs . Mesh combine system is built-in. 2D Assets support (example is not included yet). Mobile , Consoles , WebGL and PC are supported. HDRP , URP and Built-in scriptable pipeline are supported.","title":"Highlights"},{"location":"Documentation/getting-started/#tutorials","text":"how to create a procedural house how to change a house size how to change house floors how the domik builds a house how to change room walls how to replace models or materials how to add new stuff how to create and use a placeable object facades workflow how to create a preview system deep dive into house building process","title":"Tutorials"},{"location":"Documentation/getting-started/#main-concepts","text":"house generator preview system part part builder skin palette palettes random container place mask placeable object placeable objects container floor interior floor tag pipeline","title":"Main Concepts"},{"location":"Documentation/getting-started/#pipeline-nodes","text":"Action: extract positions find and replace shift Add: add part Filter: filter by mask filter by positions filter by tag filter floor filter internal doors places filter intersections filter neighbor cells filter random cells filter random input filter with part filter with parts filter without part Flow: exclude merge override shuffle Interiors: calculate room interiors place furniture return interiors split into rooms Main: end start Place: place part by mask for all rotations place placeable object forced place placeable object place stairs Remove: apply parts removing remove part remove part later Skins: create skins layer override skins layer return skins layer","title":"Pipeline Nodes"},{"location":"Documentation/house-generator/","text":"House Generator \u00b6 The House Generator component is an entry point to start generation of the house. This component provides a setting and construction of the house, and it's designed as a standalone component without any references to editor, so you can just duplicate it, wrap it to a prefab or doing something else. Read More: how to create a procedural house . Generate section \u00b6 Generate Random - click it to generate a house with a random seed . Seed - a seed number which uses to generate a house. Read More . Generate - click it to generate a house from the current seed number. Pretty useful to regenerate a house after some changes to see a difference. Pipeline - a reference to the Pipeline Node Graph asset. If you want to change rules of generation you, have to change it. Combining Mode - defines how meshes of the house should be combined: Realtime - Fast. Vertices welding and normals recalculation are disabled, so expect some artefacts on seams between flat meshes (walls, floor, ceiling etc.). The backed lighting also will be broken. Good choice for rogue-like games or to fast check some changes, btw. Baked - very slow but artefacts free. Good choice for final creating of the house. Can be used in realtime too, but it can be too slow for it. Base Size section \u00b6 This panel defines the target size of the house. Width - target width of the house. Length - target length of the house. Floors - target floors count. You can select between two size modes: const and rand . Const - constant size. Rand - random size. Why the final size may differ than the target size? These values not using directly, but send to the Pipeline , so the final size of the house depends on the Pipeline algorithm. Read More: how to change a house size . House Skins section \u00b6 This is a list of base house skins. You can think about these skins as about skins by default. Read More: facades workflow , skin . Floors section \u00b6 Floors - is a description of floors that you expect to see. Read More: how to change house floors .","title":"**House Generator**"},{"location":"Documentation/house-generator/#house-generator","text":"The House Generator component is an entry point to start generation of the house. This component provides a setting and construction of the house, and it's designed as a standalone component without any references to editor, so you can just duplicate it, wrap it to a prefab or doing something else. Read More: how to create a procedural house .","title":"House Generator"},{"location":"Documentation/house-generator/#generate-section","text":"Generate Random - click it to generate a house with a random seed . Seed - a seed number which uses to generate a house. Read More . Generate - click it to generate a house from the current seed number. Pretty useful to regenerate a house after some changes to see a difference. Pipeline - a reference to the Pipeline Node Graph asset. If you want to change rules of generation you, have to change it. Combining Mode - defines how meshes of the house should be combined: Realtime - Fast. Vertices welding and normals recalculation are disabled, so expect some artefacts on seams between flat meshes (walls, floor, ceiling etc.). The backed lighting also will be broken. Good choice for rogue-like games or to fast check some changes, btw. Baked - very slow but artefacts free. Good choice for final creating of the house. Can be used in realtime too, but it can be too slow for it.","title":"Generate section"},{"location":"Documentation/house-generator/#base-size-section","text":"This panel defines the target size of the house. Width - target width of the house. Length - target length of the house. Floors - target floors count. You can select between two size modes: const and rand . Const - constant size. Rand - random size. Why the final size may differ than the target size? These values not using directly, but send to the Pipeline , so the final size of the house depends on the Pipeline algorithm. Read More: how to change a house size .","title":"Base Size section"},{"location":"Documentation/house-generator/#house-skins-section","text":"This is a list of base house skins. You can think about these skins as about skins by default. Read More: facades workflow , skin .","title":"House Skins section"},{"location":"Documentation/house-generator/#floors-section","text":"Floors - is a description of floors that you expect to see. Read More: how to change house floors .","title":"Floors section"},{"location":"Documentation/how-the-domik-builds-a-house/","text":"How the Domik builds a house \u00b6 (\u256e\u00b0-\u00b0)\u256e\u2533\u2501\u2501\u2533 ( \u256f\u00b0\u25a1\u00b0)\u256f \u253b\u2501\u2501\u253b House is a builded cells. Cells are a grid collection of parts with positions. Parts are just names of objects that you want to see there. So, to build a house, the House Builder should find visual representations for these parts and place them in relevant positions. A visual representation of the part is a game object with a Part Builder component. From now on, we will simply refer to them as Part Builder. Part Skin Binding of a part Part Builder Result of building So, to build a Part, the house builder should find a Part Builder to it. How does it do it? The house builder will try to find it in skins. Skin is a collection of Part Builders. Skins are stored in interiors and in the House Generator skins list. Interior House Generator Interior skins have higher priority than house skins , so the House Builder will try to find it in them at first. If the house builder find a Part Builder, it'll just ask it to build this part. What does it mean for us? If we want to change something, we have to find and change its visual representation (a Part Builder) in skins. If it's a part of the room, in most situations it can be found in some interior skin, if it's a part of the facade or something common, it can be in the House Generator skins list. So how do you figure out which interior is applied to a room? You can do it visually or you can look at the name of the room, this name is the same as the name of the applied interior. Rooms Interiors How the room gets an interior? Interior of the room is set in the process of the Calculate Room Interiors node, basically this node just sets some interior from the Floor interiors list. See also: how to change room walls , how to replace models or materials .","title":"**How the Domik builds a house**"},{"location":"Documentation/how-the-domik-builds-a-house/#how-the-domik-builds-a-house","text":"(\u256e\u00b0-\u00b0)\u256e\u2533\u2501\u2501\u2533 ( \u256f\u00b0\u25a1\u00b0)\u256f \u253b\u2501\u2501\u253b House is a builded cells. Cells are a grid collection of parts with positions. Parts are just names of objects that you want to see there. So, to build a house, the House Builder should find visual representations for these parts and place them in relevant positions. A visual representation of the part is a game object with a Part Builder component. From now on, we will simply refer to them as Part Builder. Part Skin Binding of a part Part Builder Result of building So, to build a Part, the house builder should find a Part Builder to it. How does it do it? The house builder will try to find it in skins. Skin is a collection of Part Builders. Skins are stored in interiors and in the House Generator skins list. Interior House Generator Interior skins have higher priority than house skins , so the House Builder will try to find it in them at first. If the house builder find a Part Builder, it'll just ask it to build this part. What does it mean for us? If we want to change something, we have to find and change its visual representation (a Part Builder) in skins. If it's a part of the room, in most situations it can be found in some interior skin, if it's a part of the facade or something common, it can be in the House Generator skins list. So how do you figure out which interior is applied to a room? You can do it visually or you can look at the name of the room, this name is the same as the name of the applied interior. Rooms Interiors How the room gets an interior? Interior of the room is set in the process of the Calculate Room Interiors node, basically this node just sets some interior from the Floor interiors list. See also: how to change room walls , how to replace models or materials .","title":"How the Domik builds a house"},{"location":"Documentation/how-to-add-new-stuff/","text":"How to add new stuff \u00b6 From the Domik perspective there is no difference between walls, doors, furniture or something else. It's all parts . If you want to add new furniture, you have to create a new part and a visual representation of it by the part builder and the skin . That's how it works: You click the Generate button in the House Generator . The House Generator requests its Pipeline to generate house cells (each cell is a container of parts ). The Pipeline returns house cells to the House Builder . The House Builder iterates over cells and asks skins if they have some view ( PartBuilder ) for this part of the cell and if it is, the House Builder build it. Read more: how the domik builds a house , deep dive into house building process . Let's try to add a new chair to see how it works. There are two workflows which you can use to add new parts of the house: Manual - do it by your hands. Automated - trust automation. Manual \u00b6 Manual workflow is a slow and ineffective method of adding new house parts, but it's simple and intuitive . It's not recommended in most situations . First, we have to create a chair part . To do, it click on some folder -> Create -> Domik -> Part But that's not enough. The chair can have at least four rotations, so we have to add three more parts. Now let's look at the Chair Part 's inspector. Here we have references to other rotated parts. We have to set them to make things works properly. Repeat it for Chair Right , Chair Left and Chair Backward parts. Result of setting up of parts. Chair Chair Right Chair Left Chair Backward Now we need to create part builder s for these parts , to do it we have to use the skin system. We can extend an existed skin or create a brand new. Let's extend some furniture skin. To do it go to the Domik folder -> House Example -> Skins -> Furniture -> open Furniture Origin Basically, a Skin is a prefab with the Skin component , so you can use it as a regular prefab. In this example we'll open a Furniture Origin prefab because it's a root prefab. Furniture Black , Furniture White and Furniture Wooden Light are nested prefabs, so if you'll add something in the Furniture Origin prefabs it automatically will be added to these nested prefabs. Adding Part's builder to the furniture skin \u00b6 That's how the regular skin looks like. In the hierarchy window, you can see tons of objects. They're represents of look of parts. That's fine to disable objects to hide them. Disabled objects with Part Builder components will work as usual, but if you'll disable their child object, this change will affect the result of the house building. The Skin component is in the root object, select it to work with it. Now let's make a Part Builder for our chair! Drag and drop some model prefab to the skin's hierarchy to do it. Now we have to add a Part Builder component to it. After that, we have to bind this Part Builder with a Part in the Binds list in the Skin component. The number in the end is the rotation offset. Set it zero. There is no need to use it in this tutorial. Repeat it with the rest of the turns and add rotations. Congrats! Let's check out the result. If the Preview System draws parts , you did everything right. Now you can use it to create a Placeable Object ! Read next: how to create and use a placeable object , placeable object . Automated \u00b6 Another way to add new stuff is using an auto-binding. This workflow is recommended. Add that you want into the skin, name it with an [auto] prefix and click an Auto Binding button. The Skin will scan all parts in the project and if It'll find the part and the Part Builder with the same name (except prefix in square brackets) - it'll bind them together. What'll happen if there is no part for the Part Builder ? There are two variants, depends on the Create Parts for unbound? checkbox: On - parts for this Part Builder will be created in the selected folder and binded with it. Off - this Part Builder will be ignored. There are five possible prefixes: [auto] - create or find four parts with [0] , [90] , [180] , and [270] degrees rotations. [0] - create or find a part with a [0] degrees rotation. [90] - create or find a part with a [90] degrees rotation. [180] - create or find a part with a [180] degrees rotation. [270] - create or find a part with a [270] degrees rotation. Let's see it in action! Open the Furniture Origin skin and drag-n-drop the chair prefab to it's hierarchy. Add the Part Builder component to it. Add an [auto] prefix to it's name. Use name prefixes only with things which can be rotated. It'll work only if you use an auto-binding function. Go to the Skin component and enable a Create Parts for unbound? checkbox if it disabled. Now the Skin will create parts for Part Builders which doesn't have relevant parts in the project. Select a folder there you want to put new parts. Now all new parts will be created in this folder. Click an Update Binding button. We use only one Part Builder for all rotations, so there are rotation offsets to add a rotation in the process of building. The rotation offset is a number in the end of the binding field. Done! Let's check it. There is a problem: the chair rotates with little shift. That's because the chair is not in the centre of the cell. Let's fix it! To do it, move the chair to the centre of the cell. Checking out. Congratulations! Now you can use these parts to create a Placeable Object . See also: how to create and use a placeable object , placeable object .","title":"**How to add new stuff**"},{"location":"Documentation/how-to-add-new-stuff/#how-to-add-new-stuff","text":"From the Domik perspective there is no difference between walls, doors, furniture or something else. It's all parts . If you want to add new furniture, you have to create a new part and a visual representation of it by the part builder and the skin . That's how it works: You click the Generate button in the House Generator . The House Generator requests its Pipeline to generate house cells (each cell is a container of parts ). The Pipeline returns house cells to the House Builder . The House Builder iterates over cells and asks skins if they have some view ( PartBuilder ) for this part of the cell and if it is, the House Builder build it. Read more: how the domik builds a house , deep dive into house building process . Let's try to add a new chair to see how it works. There are two workflows which you can use to add new parts of the house: Manual - do it by your hands. Automated - trust automation.","title":"How to add new stuff"},{"location":"Documentation/how-to-add-new-stuff/#manual","text":"Manual workflow is a slow and ineffective method of adding new house parts, but it's simple and intuitive . It's not recommended in most situations . First, we have to create a chair part . To do, it click on some folder -> Create -> Domik -> Part But that's not enough. The chair can have at least four rotations, so we have to add three more parts. Now let's look at the Chair Part 's inspector. Here we have references to other rotated parts. We have to set them to make things works properly. Repeat it for Chair Right , Chair Left and Chair Backward parts. Result of setting up of parts. Chair Chair Right Chair Left Chair Backward Now we need to create part builder s for these parts , to do it we have to use the skin system. We can extend an existed skin or create a brand new. Let's extend some furniture skin. To do it go to the Domik folder -> House Example -> Skins -> Furniture -> open Furniture Origin Basically, a Skin is a prefab with the Skin component , so you can use it as a regular prefab. In this example we'll open a Furniture Origin prefab because it's a root prefab. Furniture Black , Furniture White and Furniture Wooden Light are nested prefabs, so if you'll add something in the Furniture Origin prefabs it automatically will be added to these nested prefabs.","title":"Manual"},{"location":"Documentation/how-to-add-new-stuff/#adding-parts-builder-to-the-furniture-skin","text":"That's how the regular skin looks like. In the hierarchy window, you can see tons of objects. They're represents of look of parts. That's fine to disable objects to hide them. Disabled objects with Part Builder components will work as usual, but if you'll disable their child object, this change will affect the result of the house building. The Skin component is in the root object, select it to work with it. Now let's make a Part Builder for our chair! Drag and drop some model prefab to the skin's hierarchy to do it. Now we have to add a Part Builder component to it. After that, we have to bind this Part Builder with a Part in the Binds list in the Skin component. The number in the end is the rotation offset. Set it zero. There is no need to use it in this tutorial. Repeat it with the rest of the turns and add rotations. Congrats! Let's check out the result. If the Preview System draws parts , you did everything right. Now you can use it to create a Placeable Object ! Read next: how to create and use a placeable object , placeable object .","title":"Adding Part's builder to the furniture skin"},{"location":"Documentation/how-to-add-new-stuff/#automated","text":"Another way to add new stuff is using an auto-binding. This workflow is recommended. Add that you want into the skin, name it with an [auto] prefix and click an Auto Binding button. The Skin will scan all parts in the project and if It'll find the part and the Part Builder with the same name (except prefix in square brackets) - it'll bind them together. What'll happen if there is no part for the Part Builder ? There are two variants, depends on the Create Parts for unbound? checkbox: On - parts for this Part Builder will be created in the selected folder and binded with it. Off - this Part Builder will be ignored. There are five possible prefixes: [auto] - create or find four parts with [0] , [90] , [180] , and [270] degrees rotations. [0] - create or find a part with a [0] degrees rotation. [90] - create or find a part with a [90] degrees rotation. [180] - create or find a part with a [180] degrees rotation. [270] - create or find a part with a [270] degrees rotation. Let's see it in action! Open the Furniture Origin skin and drag-n-drop the chair prefab to it's hierarchy. Add the Part Builder component to it. Add an [auto] prefix to it's name. Use name prefixes only with things which can be rotated. It'll work only if you use an auto-binding function. Go to the Skin component and enable a Create Parts for unbound? checkbox if it disabled. Now the Skin will create parts for Part Builders which doesn't have relevant parts in the project. Select a folder there you want to put new parts. Now all new parts will be created in this folder. Click an Update Binding button. We use only one Part Builder for all rotations, so there are rotation offsets to add a rotation in the process of building. The rotation offset is a number in the end of the binding field. Done! Let's check it. There is a problem: the chair rotates with little shift. That's because the chair is not in the centre of the cell. Let's fix it! To do it, move the chair to the centre of the cell. Checking out. Congratulations! Now you can use these parts to create a Placeable Object . See also: how to create and use a placeable object , placeable object .","title":"Automated"},{"location":"Documentation/how-to-change-a-house-size/","text":"How to change a house size \u00b6 A size of the house is controlled by the Base Size panel in the House Generator component. This panel defines the target size of the house. The final size can be different and depends on the pipeline logic. Read more: start . Width - target width of the house. Length - target length of the house. Floors - target floors count. You can select between two size modes: const and rand const - constant size. rand - random size. Const size changes Rand size changes","title":"**How to change a house size**"},{"location":"Documentation/how-to-change-a-house-size/#how-to-change-a-house-size","text":"A size of the house is controlled by the Base Size panel in the House Generator component. This panel defines the target size of the house. The final size can be different and depends on the pipeline logic. Read more: start . Width - target width of the house. Length - target length of the house. Floors - target floors count. You can select between two size modes: const and rand const - constant size. rand - random size. Const size changes Rand size changes","title":"How to change a house size"},{"location":"Documentation/how-to-change-house-floors/","text":"How to change house floors \u00b6 To change house floors, you have to edit a floors list in the Floors panel of the house generator component. This panel contains a list of floor scriptable objects, an order of list elements is inverted, so, if you want to add something like a basement floor, you have to order it to the end of the list. Flex floors are floors that can be duplicated to achieve a target size of the house, so it's better to add them in the middle of the house. Every floor contains an interior list and floor tag s. Read more: floor .","title":"**How to change house floors**"},{"location":"Documentation/how-to-change-house-floors/#how-to-change-house-floors","text":"To change house floors, you have to edit a floors list in the Floors panel of the house generator component. This panel contains a list of floor scriptable objects, an order of list elements is inverted, so, if you want to add something like a basement floor, you have to order it to the end of the list. Flex floors are floors that can be duplicated to achieve a target size of the house, so it's better to add them in the middle of the house. Every floor contains an interior list and floor tag s. Read more: floor .","title":"How to change house floors"},{"location":"Documentation/how-to-change-room-walls/","text":"How to change room walls \u00b6 In this tutorial we will change the walls of the living room. To do this, we have to work with the \"Living Room\" interior. Here we have a Skins list. This list defines how a room with this interior will look like. What is a Living Room (Palettes Random Container) in the list of skins? This interior contains a Living Room (Palettes Random Container) . The Palettes Random Container uses to select a random palette from lists of palettes. The Palette is a collection of skins which looks good together. So, a room with this interior will use skins of random palette from the Living Room (Palettes Random Container) . Top elements of the skins list will override bottoms, so to change a look of the room, we can just add a new skin in top of this list. Let's duplicate some skin, change it and add in the top of the interior skins list. Go to Domik folder -> House Example -> Skins -> Walls Here are three folders: Now open the Regular folder. These are skins. Skins are basically just prefabs with skin component on the root object and some children objects with part builder components. You can use all features of regular prefabs with them, including nesting of prefabs . Walls Origin here is an original prefab and all other wall prefabs are nested , so if you make some changes of Origin skin prefab it'll make effects on nested . We just need to change walls material so let's just duplicate some nested skin and open it to edit. This skin contains five PartBuilders . Now let's create some material and add it to the wall. Repeat it for other PartBuilders. Quit from prefab edit mode, add the result skin to the Living Room Interior and checkout the result by regenerating of house. Congrats! Now you know how to change walls of the house. Similarly, you can change the rest of the room, including the ceiling, floor and furniture.","title":"**How to change room walls**"},{"location":"Documentation/how-to-change-room-walls/#how-to-change-room-walls","text":"In this tutorial we will change the walls of the living room. To do this, we have to work with the \"Living Room\" interior. Here we have a Skins list. This list defines how a room with this interior will look like. What is a Living Room (Palettes Random Container) in the list of skins? This interior contains a Living Room (Palettes Random Container) . The Palettes Random Container uses to select a random palette from lists of palettes. The Palette is a collection of skins which looks good together. So, a room with this interior will use skins of random palette from the Living Room (Palettes Random Container) . Top elements of the skins list will override bottoms, so to change a look of the room, we can just add a new skin in top of this list. Let's duplicate some skin, change it and add in the top of the interior skins list. Go to Domik folder -> House Example -> Skins -> Walls Here are three folders: Now open the Regular folder. These are skins. Skins are basically just prefabs with skin component on the root object and some children objects with part builder components. You can use all features of regular prefabs with them, including nesting of prefabs . Walls Origin here is an original prefab and all other wall prefabs are nested , so if you make some changes of Origin skin prefab it'll make effects on nested . We just need to change walls material so let's just duplicate some nested skin and open it to edit. This skin contains five PartBuilders . Now let's create some material and add it to the wall. Repeat it for other PartBuilders. Quit from prefab edit mode, add the result skin to the Living Room Interior and checkout the result by regenerating of house. Congrats! Now you know how to change walls of the house. Similarly, you can change the rest of the room, including the ceiling, floor and furniture.","title":"How to change room walls"},{"location":"Documentation/how-to-create-a-preview-system/","text":"","title":"How to create a preview system"},{"location":"Documentation/how-to-create-a-procedural-house/","text":"How to create a procedural house \u00b6 There are two ways to create a procedural house. Drag-and-drop a prefab Open the Domik folder Select House Example prefab Drag-n-Drop it on the scene. Select it on the scene Click Generate From Random button in the Inspector. Create as a new gameobject in the scene Create new gameobject in the scene. Add a House Generator component to it. Select a Regular House pipeline in the pipeline property in the House Generator component. Set house sizes in the Base Size menu. Add a Regular Floor skin to the House Skins property. Add a Basement floor, FLEX Regular Floor and a Roof floors with correct order as it shows below. Click the Generate Random button. You can duplicate it if you want. Select House Example Prefab in the Hierarchy . Press Ctrl-D to duplicate prefab instance in the scene. Change the position on duplicated house by dragging gizmo handle. Click Generate Random button to regenerate it. Repeat. Click a Generate Random button again to randomize look of the house.","title":"**How to create a procedural house**"},{"location":"Documentation/how-to-create-a-procedural-house/#how-to-create-a-procedural-house","text":"There are two ways to create a procedural house. Drag-and-drop a prefab Open the Domik folder Select House Example prefab Drag-n-Drop it on the scene. Select it on the scene Click Generate From Random button in the Inspector. Create as a new gameobject in the scene Create new gameobject in the scene. Add a House Generator component to it. Select a Regular House pipeline in the pipeline property in the House Generator component. Set house sizes in the Base Size menu. Add a Regular Floor skin to the House Skins property. Add a Basement floor, FLEX Regular Floor and a Roof floors with correct order as it shows below. Click the Generate Random button. You can duplicate it if you want. Select House Example Prefab in the Hierarchy . Press Ctrl-D to duplicate prefab instance in the scene. Change the position on duplicated house by dragging gizmo handle. Click Generate Random button to regenerate it. Repeat. Click a Generate Random button again to randomize look of the house.","title":"How to create a procedural house"},{"location":"Documentation/how-to-create-and-use-a-placeable-object/","text":"","title":"How to create and use a placeable object"},{"location":"Documentation/how-to-replace-models-or-materials/","text":"How to replace models or materials \u00b6 If you want to change some part of the house, you have to change its Part Builder in the Skin . Skin is a container of objects with Part Builder components, which are visual representations of parts of the house. Read more: skin , part builder . Usually the house generator uses two groups of skins: House skins - contains part builders for facades , roof and so on. Interior skins - contains part builders for rooms objects: internal walls , furniture , ceiling , floor , etc. House skins contain default look of objects too. If there is no interior for the room, but this room contains a chair, the chair will be constructed by the Part Builder from some House skin . The same if no one interior skin contains a Part Builder for this Part . If house skins and interior skins don't contain a Part Builder for this Part , it'll not be builded at all. To change a look of the room, you have to change skins of an Interior that has been applied to this room. If there is no Interior for this room, you can find this skin in the House skins list . To change some basic part of the house like a facade or roof, you can do it by changing some of House skins . Interior skins list House Generator skins list Read more: how the domik builds a house Example of changing of sofa by replacing its model \u00b6 It this example, we'll change a sofa of the Living Room . To do it we have to find and change a skin which contains a Part Builder of the sofa. Note You can change a view of an object just for one Interior , and all rooms with this Interior will have this new look, but other rooms will not. To change a look of some object for all rooms, you should change it in all skins with this part of the house. Open a Furniture Origin Skin Select [auto] Chilling Section Small Remove sofa models. Add new model as a child of the [auto] Chilling Section Small game object. Fix the position. Close a prefab workspace. Re-generate the house . Example of changing of sofa by overriding its skin \u00b6 Another interesting way to replace something is skins overriding. To find out that does it mean, let's select some interior. Take a closer look at the Skins section . It's a list of skins for this interior . Order of skins is important, top skins have higher priority than down, so you can create a new skin , add sofa to it and place it in the top of skins list. In the result, this sofa will be overridden by new. Create a prefab. Add a Skin component to this prefab. Open this prefab. Create an empty GameObject . Name it exactly as object that you want to replace. Add a Part Builder component to this object. Reset it's position. Place new model as a child of this GameObject . Fix the position Click an Update Binding button in the Skin component in the prefab root. Close a prefab workspace and select an interior . Add this skin in the top of the skins list. Regenerate the house.","title":"**How to replace models or materials**"},{"location":"Documentation/how-to-replace-models-or-materials/#how-to-replace-models-or-materials","text":"If you want to change some part of the house, you have to change its Part Builder in the Skin . Skin is a container of objects with Part Builder components, which are visual representations of parts of the house. Read more: skin , part builder . Usually the house generator uses two groups of skins: House skins - contains part builders for facades , roof and so on. Interior skins - contains part builders for rooms objects: internal walls , furniture , ceiling , floor , etc. House skins contain default look of objects too. If there is no interior for the room, but this room contains a chair, the chair will be constructed by the Part Builder from some House skin . The same if no one interior skin contains a Part Builder for this Part . If house skins and interior skins don't contain a Part Builder for this Part , it'll not be builded at all. To change a look of the room, you have to change skins of an Interior that has been applied to this room. If there is no Interior for this room, you can find this skin in the House skins list . To change some basic part of the house like a facade or roof, you can do it by changing some of House skins . Interior skins list House Generator skins list Read more: how the domik builds a house","title":"How to replace models or materials"},{"location":"Documentation/how-to-replace-models-or-materials/#example-of-changing-of-sofa-by-replacing-its-model","text":"It this example, we'll change a sofa of the Living Room . To do it we have to find and change a skin which contains a Part Builder of the sofa. Note You can change a view of an object just for one Interior , and all rooms with this Interior will have this new look, but other rooms will not. To change a look of some object for all rooms, you should change it in all skins with this part of the house. Open a Furniture Origin Skin Select [auto] Chilling Section Small Remove sofa models. Add new model as a child of the [auto] Chilling Section Small game object. Fix the position. Close a prefab workspace. Re-generate the house .","title":"Example of changing of sofa by replacing its model"},{"location":"Documentation/how-to-replace-models-or-materials/#example-of-changing-of-sofa-by-overriding-its-skin","text":"Another interesting way to replace something is skins overriding. To find out that does it mean, let's select some interior. Take a closer look at the Skins section . It's a list of skins for this interior . Order of skins is important, top skins have higher priority than down, so you can create a new skin , add sofa to it and place it in the top of skins list. In the result, this sofa will be overridden by new. Create a prefab. Add a Skin component to this prefab. Open this prefab. Create an empty GameObject . Name it exactly as object that you want to replace. Add a Part Builder component to this object. Reset it's position. Place new model as a child of this GameObject . Fix the position Click an Update Binding button in the Skin component in the prefab root. Close a prefab workspace and select an interior . Add this skin in the top of the skins list. Regenerate the house.","title":"Example of changing of sofa by overriding its skin"},{"location":"Documentation/palettes-random-container/","text":"","title":"Palettes random container"},{"location":"Documentation/part-builder/","text":"Part Builder \u00b6 The Part Builder is a component which builds a part . If you want to change a look of the part , you have to change its Part Builder . Part Builders are stored in the skin - a prefab with the Skin component in the root. The skin binds parts and part builders together. The skin will try to bind a Part Builder object with four rotated parts if you'll add an [auto] prefix in the name. Part Builder component Part Builder object in the Skin Part Binding in the skin Own Part - link to an automatically bound part. This is just a debug information. Combine - do you want to combine meshes after building? Space - select the building space: Room - build it into the room space. Floor - build it into the floor space. House - build it to the house space. See also: part , skin , how to add new stuff , how to replace models or materials , how to change room walls .","title":"**Part Builder**"},{"location":"Documentation/part-builder/#part-builder","text":"The Part Builder is a component which builds a part . If you want to change a look of the part , you have to change its Part Builder . Part Builders are stored in the skin - a prefab with the Skin component in the root. The skin binds parts and part builders together. The skin will try to bind a Part Builder object with four rotated parts if you'll add an [auto] prefix in the name. Part Builder component Part Builder object in the Skin Part Binding in the skin Own Part - link to an automatically bound part. This is just a debug information. Combine - do you want to combine meshes after building? Space - select the building space: Room - build it into the room space. Floor - build it into the floor space. House - build it to the house space. See also: part , skin , how to add new stuff , how to replace models or materials , how to change room walls .","title":"Part Builder"},{"location":"Documentation/placeable-object/","text":"Placeable Object \u00b6 The Placeable Object is a container for the part with placing requirements. How to create a Placeable Object? To create a new placeable object , select some folder in the Project window -> Right Mouse Click -> Create -> Domik -> Placeable Object Preview section \u00b6 The Preview section helps you to work with the preview system . This system will draw a result of changes of selected Placeable Object . Turn - select a turn of preview. Build button - press it to rebuild preview manually. Find button - press it to find the Preview system instance in the scene. Settings section \u00b6 The settings section defines that you want to place and where you want to place. Part - the part that you want to place. Changing of the part Possible Places - this is a list of places where this part can be. You can use place s or mask s here. Changing of list of possible places Select of the place Multiple places Actions after placing \u00b6 This section is designed to help you to change an environment of the part after placing. Floor - a floor what you want to change: Top - cells on the floor above of the part . Current - cells of the same floor as the part . Down - cells on the floor below of the part . Here you can see a cells grid. Click on some cell to start working with it. In the panel below, you can see two lists: remove list - parts what you want to remove from this cell . add list - parts what you want to add to this cell . Added and removed parts will be showed on the preview with transparent green and red materials.","title":"**Placeable Object**"},{"location":"Documentation/placeable-object/#placeable-object","text":"The Placeable Object is a container for the part with placing requirements. How to create a Placeable Object? To create a new placeable object , select some folder in the Project window -> Right Mouse Click -> Create -> Domik -> Placeable Object","title":"Placeable Object"},{"location":"Documentation/placeable-object/#preview-section","text":"The Preview section helps you to work with the preview system . This system will draw a result of changes of selected Placeable Object . Turn - select a turn of preview. Build button - press it to rebuild preview manually. Find button - press it to find the Preview system instance in the scene.","title":"Preview section"},{"location":"Documentation/placeable-object/#settings-section","text":"The settings section defines that you want to place and where you want to place. Part - the part that you want to place. Changing of the part Possible Places - this is a list of places where this part can be. You can use place s or mask s here. Changing of list of possible places Select of the place Multiple places","title":"Settings section"},{"location":"Documentation/placeable-object/#actions-after-placing","text":"This section is designed to help you to change an environment of the part after placing. Floor - a floor what you want to change: Top - cells on the floor above of the part . Current - cells of the same floor as the part . Down - cells on the floor below of the part . Here you can see a cells grid. Click on some cell to start working with it. In the panel below, you can see two lists: remove list - parts what you want to remove from this cell . add list - parts what you want to add to this cell . Added and removed parts will be showed on the preview with transparent green and red materials.","title":"Actions after placing"},{"location":"Documentation/placeable-objects-container/","text":"Placeable Objects Container \u00b6 The Placeable Objects Container is a container of placeable object s or other placeable objects container s. It's designed to group up objects which can present some common idea. Use it with objects which can or should be represented by different parts . Mode - a placing mode: Place All - try to place all items. Use it to group up objects by some topic to make an interior list of placeable objects a bit cleaner. Place First Relevant - iterate over items and stop after the first success of placing. Use it if these items represent an object that trying to adapt to different environments. Example: kitchen stoves for different sizes of the room. Place Random Relevant - place only one item by random. Use it if these items are just variants of one object. Example: a picture on the wall. Placeable Objects list - a list of items that you want to try to place. You can even make a container and fill it with other containers, and it'll try to place all child containers.","title":"**Placeable Objects Container**"},{"location":"Documentation/placeable-objects-container/#placeable-objects-container","text":"The Placeable Objects Container is a container of placeable object s or other placeable objects container s. It's designed to group up objects which can present some common idea. Use it with objects which can or should be represented by different parts . Mode - a placing mode: Place All - try to place all items. Use it to group up objects by some topic to make an interior list of placeable objects a bit cleaner. Place First Relevant - iterate over items and stop after the first success of placing. Use it if these items represent an object that trying to adapt to different environments. Example: kitchen stoves for different sizes of the room. Place Random Relevant - place only one item by random. Use it if these items are just variants of one object. Example: a picture on the wall. Placeable Objects list - a list of items that you want to try to place. You can even make a container and fill it with other containers, and it'll try to place all child containers.","title":"Placeable Objects Container"},{"location":"Documentation/preview-system/","text":"Preview System \u00b6 The Preview System draws configuration files right in the scene. It's pretty useful tool to work with them because you can see changes of files visually in real time. A done Preview System is a prefab in the Domik folder. Drag-and-drop it in the scene to start working with it. The Preview System works with: Part Mask Place Placeable Object Part Preview \u00b6 The Part Preview allows you to see a visual representation of the part . Place Preview \u00b6 The Place Preview allows you to see a visual representation of the place . You can see changes of some Place instantly. Mask Preview \u00b6 The Mask Preview allows you to see a visual representation of the mask . You can see changes of some Mask instantly. Placeable Object Preview \u00b6 The Placeable Object Preview allows you to see a visual representation of the placeable object . You can see changes of some Placeable Object instantly. Changing of the part Changing of the place Select of places Changing of actions after placing See also: how to create a preview system .","title":"**Preview System**"},{"location":"Documentation/preview-system/#preview-system","text":"The Preview System draws configuration files right in the scene. It's pretty useful tool to work with them because you can see changes of files visually in real time. A done Preview System is a prefab in the Domik folder. Drag-and-drop it in the scene to start working with it. The Preview System works with: Part Mask Place Placeable Object","title":"Preview System"},{"location":"Documentation/preview-system/#part-preview","text":"The Part Preview allows you to see a visual representation of the part .","title":"Part Preview"},{"location":"Documentation/preview-system/#place-preview","text":"The Place Preview allows you to see a visual representation of the place . You can see changes of some Place instantly.","title":"Place Preview"},{"location":"Documentation/preview-system/#mask-preview","text":"The Mask Preview allows you to see a visual representation of the mask . You can see changes of some Mask instantly.","title":"Mask Preview"},{"location":"Documentation/preview-system/#placeable-object-preview","text":"The Placeable Object Preview allows you to see a visual representation of the placeable object . You can see changes of some Placeable Object instantly. Changing of the part Changing of the place Select of places Changing of actions after placing See also: how to create a preview system .","title":"Placeable Object Preview"},{"location":"Knowledge%20Base/Modular%20System%20Adaptation/","text":"","title":"Modular System Adaptation"},{"location":"Old%20stuff/GettingStarted/","text":"Getting Started \u00b6 The Domik is a procedural house generator for Unity3D. Features: - Interiors and Furniture - empty basic rooms? Not today :D - Pipeline: a node graph based visual language - program your own house system just by drag'n'drop nodes! - Skins support - use your own look for the house. - Place: a 3D describing system - show for the Pipeline what you want to find and change. - Mesh Combine System - strong optimization by one click. - Easy to learn hard to master - To make your first procedural house just drop the House Generator prefab to the scene and press the \"Generate\" button. - Runtime support - make a brand new rougelike game! - Seed - one number to rule them all. The Domik is a one-button solution, so to start working with it you should just drag-n-drop the House Generator prefab to the scene and click \u201cGenerate Random\u201d button.","title":"Getting Started"},{"location":"Old%20stuff/GettingStarted/#getting-started","text":"The Domik is a procedural house generator for Unity3D. Features: - Interiors and Furniture - empty basic rooms? Not today :D - Pipeline: a node graph based visual language - program your own house system just by drag'n'drop nodes! - Skins support - use your own look for the house. - Place: a 3D describing system - show for the Pipeline what you want to find and change. - Mesh Combine System - strong optimization by one click. - Easy to learn hard to master - To make your first procedural house just drop the House Generator prefab to the scene and press the \"Generate\" button. - Runtime support - make a brand new rougelike game! - Seed - one number to rule them all. The Domik is a one-button solution, so to start working with it you should just drag-n-drop the House Generator prefab to the scene and click \u201cGenerate Random\u201d button.","title":"Getting Started"},{"location":"Old%20stuff/Getting%20Started/Add%20new%20furniture/","text":"Add new furniture \u00b6 Now let's add something new to the house. Something like a chair and candellar. First, we need to have a prefab for new furniture, so let's make them. prepare new furniture prefabs gif Now we should add them to the base House Generator skin open skin and add new prefabs to root Add Part Builder component to prefabs Part builder components adding Unlike candellar, chair can be rotated around, so we shall to add an [auto] prefix to it's name prefix gif Now select skin prefab root and click Update Binding button. Wait some time, that's not an instant process. Binging update Yay! We did it. Now it's time to check binding. Select created parts and checkout Part reference Check binding To be sure that everything works fine select Skin root and find created binds Finding binds So here we have these five binds candelar bind chair binds As you can see chair contains four binds and candellar contains one bind. That's because chair can be rotated by 90, 180 and 270 degresses unlike candellar. Save skin prefab and close save and close skin prefab Next we should create Placeable Objects for new furniture, however, there is something to be done before. To work effective you should use a Preview system. It'll show all changes of Placeable Objects, Places and Masks instantly. To do it just select Preview prefab and drop it on the scene. Drop preview Now it's time to create Placeable Objects for new furnitures. create new placeable objects for chair and candellar Select them and add references it relevant parts select po and add part references Now we should define where we want to place this furniture. To do it select some places in Place field Select places for PO Preview shows how placing furniture will looks in the requested place. We made our first Placeable Object. Basically, Placeable Object is a part with place description where it should be placed. Next we should add it to Interior. To do it select some interior and add placeable objects to the furniture list Adding placeable objects to skin furniture list Now let's checkout what this interior is added to some floor Select House Generator and checking interior list Yay, that's here. Now it's time to check results! To do it just click Generate Button and try to find our furniture in the house: Checking house","title":"Add new furniture"},{"location":"Old%20stuff/Getting%20Started/Add%20new%20furniture/#add-new-furniture","text":"Now let's add something new to the house. Something like a chair and candellar. First, we need to have a prefab for new furniture, so let's make them. prepare new furniture prefabs gif Now we should add them to the base House Generator skin open skin and add new prefabs to root Add Part Builder component to prefabs Part builder components adding Unlike candellar, chair can be rotated around, so we shall to add an [auto] prefix to it's name prefix gif Now select skin prefab root and click Update Binding button. Wait some time, that's not an instant process. Binging update Yay! We did it. Now it's time to check binding. Select created parts and checkout Part reference Check binding To be sure that everything works fine select Skin root and find created binds Finding binds So here we have these five binds candelar bind chair binds As you can see chair contains four binds and candellar contains one bind. That's because chair can be rotated by 90, 180 and 270 degresses unlike candellar. Save skin prefab and close save and close skin prefab Next we should create Placeable Objects for new furniture, however, there is something to be done before. To work effective you should use a Preview system. It'll show all changes of Placeable Objects, Places and Masks instantly. To do it just select Preview prefab and drop it on the scene. Drop preview Now it's time to create Placeable Objects for new furnitures. create new placeable objects for chair and candellar Select them and add references it relevant parts select po and add part references Now we should define where we want to place this furniture. To do it select some places in Place field Select places for PO Preview shows how placing furniture will looks in the requested place. We made our first Placeable Object. Basically, Placeable Object is a part with place description where it should be placed. Next we should add it to Interior. To do it select some interior and add placeable objects to the furniture list Adding placeable objects to skin furniture list Now let's checkout what this interior is added to some floor Select House Generator and checking interior list Yay, that's here. Now it's time to check results! To do it just click Generate Button and try to find our furniture in the house: Checking house","title":"Add new furniture"},{"location":"Old%20stuff/Getting%20Started/Change%20an%20interior%20furniture%20look/","text":"Change an interior furniture look \u00b6 You can also change look of some furniture as we did it for wallpapers before. Two tabs, one for change by changing mesh. and second by changing whole object and refresh skin binding To do it open an interior skin and -> replace existed furniture","title":"Change an interior furniture look"},{"location":"Old%20stuff/Getting%20Started/Change%20an%20interior%20furniture%20look/#change-an-interior-furniture-look","text":"You can also change look of some furniture as we did it for wallpapers before. Two tabs, one for change by changing mesh. and second by changing whole object and refresh skin binding To do it open an interior skin and -> replace existed furniture","title":"Change an interior furniture look"},{"location":"Old%20stuff/Getting%20Started/Change%20exterior/","text":"Change exterior \u00b6 Advanced House Generator example contains configurated tags system, so you can change generation process just by changing tags Three columns, one for changing windows, second for changing doors and third for changing facade Change house exterior materials \u00b6 To change materials or mesh just open a base skin in House Generator and change Part Builders materials or meshes Open base skin: -> Select [0]External Wall -> Change material -> Select [0]External Window -> Change material -> Select [0]External Doorway -> Change material","title":"Change exterior"},{"location":"Old%20stuff/Getting%20Started/Change%20exterior/#change-exterior","text":"Advanced House Generator example contains configurated tags system, so you can change generation process just by changing tags Three columns, one for changing windows, second for changing doors and third for changing facade","title":"Change exterior"},{"location":"Old%20stuff/Getting%20Started/Change%20exterior/#change-house-exterior-materials","text":"To change materials or mesh just open a base skin in House Generator and change Part Builders materials or meshes Open base skin: -> Select [0]External Wall -> Change material -> Select [0]External Window -> Change material -> Select [0]External Doorway -> Change material","title":"Change house exterior materials"},{"location":"Old%20stuff/Getting%20Started/Change%20wallpapers/","text":"Change wallpapers \u00b6 Now let's make a little bit change of some room. New wallpappers! So, to do it we should change some interior skin. Select interior -> Skin Settings -> open skin Open interior skin Now lets select [0] internal wall and change it's material Select internal wall and change it's material Now lets select [0] internal window and change it's material Select internal window and change it's material Now lets select [0] internal doorway and change it's material Select internal doorway and change it's material if some PartBuilder gameobject disabled it's okay, it'll works fine. Save changes and check result Save and check","title":"Change wallpapers"},{"location":"Old%20stuff/Getting%20Started/Change%20wallpapers/#change-wallpapers","text":"Now let's make a little bit change of some room. New wallpappers! So, to do it we should change some interior skin. Select interior -> Skin Settings -> open skin Open interior skin Now lets select [0] internal wall and change it's material Select internal wall and change it's material Now lets select [0] internal window and change it's material Select internal window and change it's material Now lets select [0] internal doorway and change it's material Select internal doorway and change it's material if some PartBuilder gameobject disabled it's okay, it'll works fine. Save changes and check result Save and check","title":"Change wallpapers"},{"location":"Old%20stuff/Getting%20Started/Create%20Interior/","text":"","title":"Create Interior"},{"location":"Old%20stuff/Getting%20Started/Create%20Pipeline/","text":"Create Pipeline \u00b6 The Pipeline is a visual scripting language which uses to generate a house. (\u0421\u043f\u0440\u044f\u0442\u0430\u0442\u044c \u044d\u0442\u0443 \u0445\u0443\u0439\u043d\u044e \u043f\u043e\u0434 \u043a\u0430\u0442) How to create and use the Pipeline asset \u00b6 To create a new Pipeline asset right click on some folder -> Create -> Domik -> Pipeline. Create pipeline process To start working with it open it by double clicking Opening pipeline process Now you see the Pipeline window. It's empty and useless. To make it little bit useful right click somethere -> Add Node -> Flow -> Start Start node adding process Drag pin right and release it -> Add -> Add Part Add Part node Drag pin right and release it -> Type \"End\" to the search -> End End node adding process Click Part field in the Add Part node and select Floor part select floor part Save and close the window save and close Now drag this Pipeline to some House Generator pipeline field and click Generate button drag and click generate Here is the result. No, that's not looks like a good place to live, but, at least, now you understand how to works with the Pipeline. To revert changes just select previous Pipeline Select previous pipeline and check it","title":"Create Pipeline"},{"location":"Old%20stuff/Getting%20Started/Create%20Pipeline/#create-pipeline","text":"The Pipeline is a visual scripting language which uses to generate a house. (\u0421\u043f\u0440\u044f\u0442\u0430\u0442\u044c \u044d\u0442\u0443 \u0445\u0443\u0439\u043d\u044e \u043f\u043e\u0434 \u043a\u0430\u0442)","title":"Create Pipeline"},{"location":"Old%20stuff/Getting%20Started/Create%20Pipeline/#how-to-create-and-use-the-pipeline-asset","text":"To create a new Pipeline asset right click on some folder -> Create -> Domik -> Pipeline. Create pipeline process To start working with it open it by double clicking Opening pipeline process Now you see the Pipeline window. It's empty and useless. To make it little bit useful right click somethere -> Add Node -> Flow -> Start Start node adding process Drag pin right and release it -> Add -> Add Part Add Part node Drag pin right and release it -> Type \"End\" to the search -> End End node adding process Click Part field in the Add Part node and select Floor part select floor part Save and close the window save and close Now drag this Pipeline to some House Generator pipeline field and click Generate button drag and click generate Here is the result. No, that's not looks like a good place to live, but, at least, now you understand how to works with the Pipeline. To revert changes just select previous Pipeline Select previous pipeline and check it","title":"How to create and use the Pipeline asset"},{"location":"Old%20stuff/Getting%20Started/Create%20Preview%20System/","text":"Create Preview System \u00b6 Preview is a visualisation system for Domik scriptable objects. Prepare \u00b6 Open Domik folder in project -> Select Preview prefab -> Drop it to the scene dropping preview gif Usage \u00b6 Then you select Part, Place, Placeable Object or Mask, Preview will render it's visual representation, so you can change them and see results imidiately for tabs which shows usaging wigh part, place, po and mask See also \u00b6 Preview","title":"Create Preview System"},{"location":"Old%20stuff/Getting%20Started/Create%20Preview%20System/#create-preview-system","text":"Preview is a visualisation system for Domik scriptable objects.","title":"Create Preview System"},{"location":"Old%20stuff/Getting%20Started/Create%20Preview%20System/#prepare","text":"Open Domik folder in project -> Select Preview prefab -> Drop it to the scene dropping preview gif","title":"Prepare"},{"location":"Old%20stuff/Getting%20Started/Create%20Preview%20System/#usage","text":"Then you select Part, Place, Placeable Object or Mask, Preview will render it's visual representation, so you can change them and see results imidiately for tabs which shows usaging wigh part, place, po and mask","title":"Usage"},{"location":"Old%20stuff/Getting%20Started/Create%20Preview%20System/#see-also","text":"Preview","title":"See also"},{"location":"Overview%20-%20delete%20me/House%20Generator%20OLD/","text":"House Generator \u00b6 The House Generator component is the entry point to start generation of house. ![[Pasted image 20210105135339.png]] To create a house generator: - Right Click on the scene hierarchy -> Create Empty -> select created gameObject -> AddComponent -> House Generator. - Just drag-n-drop existed house generator prefab to the scene. Generate Section \u00b6 Generate Random - triggers a house generation with random Seed. Seed - a number which uses to generate a house. Generate - triggers a house generation from current Seed. Pretty useful for regenerate a house after some changes. Pipeline - a reference to Pipeline Node Graph instance. If you want to change a generation rules just change the pipeline! Combining Mode - how accurate House Builder should combine meshes. Realtime - fast but with artifacts. Pretty suitable for realtime generation or if you want to check what happens after some changes. Baked - long but artifacts free. You can use it in realtime also! House Skins \u00b6 Here is a list of base house skins. You can think about these skins as about skins by default. Floors \u00b6 Floors is a description of expected house floors.","title":"House Generator"},{"location":"Overview%20-%20delete%20me/House%20Generator%20OLD/#house-generator","text":"The House Generator component is the entry point to start generation of house. ![[Pasted image 20210105135339.png]] To create a house generator: - Right Click on the scene hierarchy -> Create Empty -> select created gameObject -> AddComponent -> House Generator. - Just drag-n-drop existed house generator prefab to the scene.","title":"House Generator"},{"location":"Overview%20-%20delete%20me/House%20Generator%20OLD/#generate-section","text":"Generate Random - triggers a house generation with random Seed. Seed - a number which uses to generate a house. Generate - triggers a house generation from current Seed. Pretty useful for regenerate a house after some changes. Pipeline - a reference to Pipeline Node Graph instance. If you want to change a generation rules just change the pipeline! Combining Mode - how accurate House Builder should combine meshes. Realtime - fast but with artifacts. Pretty suitable for realtime generation or if you want to check what happens after some changes. Baked - long but artifacts free. You can use it in realtime also!","title":"Generate Section"},{"location":"Overview%20-%20delete%20me/House%20Generator%20OLD/#house-skins","text":"Here is a list of base house skins. You can think about these skins as about skins by default.","title":"House Skins"},{"location":"Overview%20-%20delete%20me/House%20Generator%20OLD/#floors","text":"Floors is a description of expected house floors.","title":"Floors"},{"location":"Overview%20-%20delete%20me/How%20to%20create%20new%20floor%20OLD/","text":"How to create floor \u00b6 To create new floor select some folder in the Project window -> Right Mouse Click -> Create -> Domik -> Floor Now you can configure new floor. Flex - can this floor be duplicated to fit target house size? Set true for middle floors and false for floors with roof or basement. Interiors - here you can define a set of interiors which can be on this floor. Floor Tags - a set of tags which will be used by the Pipeline to customize this floor.","title":"How to create floor"},{"location":"Overview%20-%20delete%20me/How%20to%20create%20new%20floor%20OLD/#how-to-create-floor","text":"To create new floor select some folder in the Project window -> Right Mouse Click -> Create -> Domik -> Floor Now you can configure new floor. Flex - can this floor be duplicated to fit target house size? Set true for middle floors and false for floors with roof or basement. Interiors - here you can define a set of interiors which can be on this floor. Floor Tags - a set of tags which will be used by the Pipeline to customize this floor.","title":"How to create floor"},{"location":"Overview%20-%20delete%20me/Interior%20OLD/","text":"Interior \u00b6 Interior is a scriptable object with info about room transformation. (Yea, that's just an interior, lol). Place Interiors Node will try to find suitable interiors for all rooms in the house. Furniture \u00b6 Furniture - a list of Placeable Object OLD or [[Placeable Objects Container OLD]]. Add here all that you want to see in this room. Skins \u00b6 Skins - skins which will override a Base Skin from the House Generator OLD . If you want to change a default look of walls, ceiling, floor, etc. just make new Skin with different materials for them and add here. Placing Rules \u00b6 Here you can write special requirements for room. - Max Count Per Floor - limit for that type of interiors per floor. If you don't want to have more than two toilets per floor just write here 2 . - Prefer Room - requirements for room size - Small - prefer small rooms - Medium - prefer medium rooms - Big - prefer big rooms - Random - you don't care Parts Limit \u00b6 Here you can describe which parts you don't want to see in this interior. If you don't want to have windows in the toilet add a window part here and select an Unacceptable mode. Possible States \u00b6 - Fixed - you want to see the concrete count of this part in this room - Rande - count of this Part can be in range between min and max. - At least one - acceptable if this room has at least one exemplar of this part - Unacceptable - this part is prohibited in this room","title":"Interior"},{"location":"Overview%20-%20delete%20me/Interior%20OLD/#interior","text":"Interior is a scriptable object with info about room transformation. (Yea, that's just an interior, lol). Place Interiors Node will try to find suitable interiors for all rooms in the house.","title":"Interior"},{"location":"Overview%20-%20delete%20me/Interior%20OLD/#furniture","text":"Furniture - a list of Placeable Object OLD or [[Placeable Objects Container OLD]]. Add here all that you want to see in this room.","title":"Furniture"},{"location":"Overview%20-%20delete%20me/Interior%20OLD/#skins","text":"Skins - skins which will override a Base Skin from the House Generator OLD . If you want to change a default look of walls, ceiling, floor, etc. just make new Skin with different materials for them and add here.","title":"Skins"},{"location":"Overview%20-%20delete%20me/Interior%20OLD/#placing-rules","text":"Here you can write special requirements for room. - Max Count Per Floor - limit for that type of interiors per floor. If you don't want to have more than two toilets per floor just write here 2 . - Prefer Room - requirements for room size - Small - prefer small rooms - Medium - prefer medium rooms - Big - prefer big rooms - Random - you don't care","title":"Placing Rules"},{"location":"Overview%20-%20delete%20me/Interior%20OLD/#parts-limit","text":"Here you can describe which parts you don't want to see in this interior. If you don't want to have windows in the toilet add a window part here and select an Unacceptable mode.","title":"Parts Limit"},{"location":"Overview%20-%20delete%20me/Interior%20OLD/#possible-states","text":"- Fixed - you want to see the concrete count of this part in this room - Rande - count of this Part can be in range between min and max. - At least one - acceptable if this room has at least one exemplar of this part - Unacceptable - this part is prohibited in this room","title":"Possible States"},{"location":"Overview%20-%20delete%20me/Mask%20OLD/","text":"Mask \u00b6 Mask, also known as adjacency mask, is a description about accessibility from central cell to neighbour cells. You can use it as way as Place OLD , but in more brutal manner. Use it if you wan't to find house or rooms borders, some holes or something like that, and you don't care about parts inside of them. Space - what type of adjacency you want to check House - cell is accessible if exists in the house. Good choice if you want to find something like a borders of house. Room - cells is accessible if exists in the house and if it has the same RoomID as the current cell. Use it if you want to find borders of rooms. Floor - changes floor for cells grid panel Grid of cells - click on the cell which checking status you want to change. State - which accessibility status this cell should have? Accessible - this cell should be accessible from current cell Inaccessible - this cell should be inaccessible from current cell","title":"Mask"},{"location":"Overview%20-%20delete%20me/Mask%20OLD/#mask","text":"Mask, also known as adjacency mask, is a description about accessibility from central cell to neighbour cells. You can use it as way as Place OLD , but in more brutal manner. Use it if you wan't to find house or rooms borders, some holes or something like that, and you don't care about parts inside of them. Space - what type of adjacency you want to check House - cell is accessible if exists in the house. Good choice if you want to find something like a borders of house. Room - cells is accessible if exists in the house and if it has the same RoomID as the current cell. Use it if you want to find borders of rooms. Floor - changes floor for cells grid panel Grid of cells - click on the cell which checking status you want to change. State - which accessibility status this cell should have? Accessible - this cell should be accessible from current cell Inaccessible - this cell should be inaccessible from current cell","title":"Mask"},{"location":"Overview%20-%20delete%20me/Nodes/","text":"Nodes \u00b6 Here is a list of avaliable nodes which you can use do write the Pipeline logic. To create a new node Right Click in the graph -> Create Node -> Select Category -> Select Node Action Nodes \u00b6 Create Override Skin Layer node \u00b6 The Create Override Skin Layer node creates a special layer which you can use to define cells which should use a special skin. It'll not override other skins in this cells, instead of it it'll add a new skin in the top of skin applying queue. Parameters: skin - a Skin which will be used to create a Skin Layer Find And Replace Node \u00b6 Finds Cells with target Part and replaces the target part with the newPart on them. Parameters : target - part which we want to replace newPart - part which will replace Extract Positions Node \u00b6 The Extract Positions node extracts positions of input node to the output positions array. Merge Override Skin Layers Node \u00b6 The Merge Override Skin Layers node merges input layers to one layer. Shift Node \u00b6 The Shift node shifts positions for all input cells. Parameters: X - x axis offset Y - y axis offset Floor - floor offset Split Into Rooms Node \u00b6 The Split Into Rooms node splits input cells to rooms by overriding their roomIDs. Strongly Recommended to use before [[Place Interiors node]]. Parameters: Min Size - the minimum possible size of rooms Max Size - the minimum possible size of rooms Add nodes \u00b6 Add Part Node \u00b6 The Add Part node adds a part to the input cells. Before Add Part After Add Part Add Part to Part Node \u00b6 The Add Part to Part node filters cells by part and add another part to these cells. Parameters: - target - a [[Part OLD]] which will be used as filter - part - a [[Part OLD]] which will be added to filtered cells - mode - No Rotation - just find cells with target [[Part OLD]] and add new part to them - Rotate Only Target - find cells with all possible target rotations and add new part to them - Rotate Target And Part - sync target part and new part rotations. Before After Add Roof Cells Node \u00b6 The Add Roof Cells node adds additional cells in tops of input cells. Result looks like a pyramid. Before After Filter nodes \u00b6 Filter By Added Floors Node \u00b6 The Filter By Added Floors node filters cells which positioned on the floors which wasn't described in the Floors House Generator menu. Parameters: Invert - return cells without added floors. Filter By Floor Node \u00b6 The Filter By Floor node filters cells positioned on the target floor. Parameters: int field - floor which you want to filter Filter By Mask Node \u00b6 The Filter By Mask node returns cells filtered by special mask. Parameters: Mask - a mask which you want to use as filter Filter By Positions Node \u00b6 The Filter By Positions node returns cells which has the same positions as in input Positions array. Filter By Tag Node \u00b6 The FiIter By Tag node returns cells with target Tag. Input: In - all cells which we want to filter Positions - cells positions array which we want to use as a filter Filter Internel Doors Places Node \u00b6 The Filter By Internal Doors Places analyzes input cells and returns suitable cellses for doors between rooms. Output: Forward - Cells where you should add the door part which shouldn't be rotated Backward - Cells where you should add the door part which should be rotated by 180 degress. Right - Cells where you should add the door part which should be rotated by 90 degress. Left - Cells where you should add the door part which should be rotated by 270 degress. Filter Interse\u0441tions Node \u00b6 The Filter Intersections node returns cells whose positions intersect, so if you have cells set with positions [0, 0, 0] , [0, 1, 0], [1, 1, 0] and [3, 4, 0], [0, 0, 0] , [1, 1, 0] , [3, 4, 1], the result will be -> [0, 0, 0] , [1, 1, 0] . Filter Neighbour Cells Node \u00b6 The Filter Neighbour Cells node returns neighbour cells sorted by directions. Filter Random Cell Node \u00b6 The Filter Random Cell node returns a random cell from input cells. Filter Random Input Node \u00b6 The Filter Random Input node returns cells from a random input. Filter With Part Node \u00b6 The Filter With Part node returns cells with a target part. Filter Without Part Node \u00b6 The Filter Without Part node returns cells without a target part. Flow \u00b6 Exclude Node \u00b6 The Exclude node returns cells from A input but without cells from B input. Merge Node \u00b6 The Merge node merges cells from input into one cells set (parts sets also will be merged) and then returns them. Override Node \u00b6 The Override node merges input cells into one cells set, but intersected cells from an A input will be overrode by cells from a B input. Shuffle Node \u00b6 The Shuffle node shuffles an input cells array. That's not change cells positions or other sort of data, it just makes a chaotic reordering of an input cells set. Main Nodes \u00b6 End Node \u00b6 The End node returns an input cells as a result of Pipeline working. The Pipeline should always have one (and only one) End node or it'll not working properly. You can also use this node for debugging, just connect an input of this node with output of some node to see that's happening in this step of generation. Start Node \u00b6 The Start node is an entry point of generation process. This node collects data stored in the House Generator component and use them to make a house draft. The Start node returns a set of cells which represents a gabarits of house, but these cells has no parts, they aren't splitted by rooms and so on. That's just raw cells. Place Nodes \u00b6 Place Interiors Node \u00b6 The Place Interiors node analysis input cells and sets a relevent interior for them. It also places furniture. Place Part Node \u00b6 The Place Part node filters cells by mask and add a [[Part OLD]] to them. Place Placeable Object Forced Node \u00b6 Unlike Place Placeable Object node, this node ignores placing requirements and just place this Placeable Object on input cell. Input : All - all accessible cells, needs to run actions after placing (read Placeable Object OLD ). Target - here you want to place this PlaceableObject. Parameters : placeableObject - a Placeable Object which you want to place turn - how you want to turn it when placing Place Placeable Object Node \u00b6 The Place Placeable Object node places a PlaceableObject ot input cells. Parameters: Placing Mode: One Per House - try to place Placeable Object only once. One Per Floor - try to place Placeable Object once on every accessible floor. One Per Room - try to place Placeable Object once on every room. One Per Cell - try to place Placeable Object on every input cell. Place Stairs Node \u00b6 The Place Stairs node tires to place stairs in the longest stairwells. Your house can have more than one stairwell, mostly because of difference between floors planning. Cells of floors which wasn't successfully connected returns to the Failed output, so you can handle them by less demanding rules. input: In - cells to process Forbidden - cells which inaccessible for stairs placing output: Successful - cells of floors which was connected by placed stairs. Failed - cells of floors which wasn't connected by stairwell parameters: stairs - a Placeable Object which represents stairs minStairwellLenght - minimal length of stairwell Remove Nodes \u00b6 Remove Part Node \u00b6 The Remove Part node removes a part from all input cells.","title":"**Nodes**"},{"location":"Overview%20-%20delete%20me/Nodes/#nodes","text":"Here is a list of avaliable nodes which you can use do write the Pipeline logic. To create a new node Right Click in the graph -> Create Node -> Select Category -> Select Node","title":"Nodes"},{"location":"Overview%20-%20delete%20me/Nodes/#action-nodes","text":"","title":"Action Nodes"},{"location":"Overview%20-%20delete%20me/Nodes/#create-override-skin-layer-node","text":"The Create Override Skin Layer node creates a special layer which you can use to define cells which should use a special skin. It'll not override other skins in this cells, instead of it it'll add a new skin in the top of skin applying queue. Parameters: skin - a Skin which will be used to create a Skin Layer","title":"Create Override Skin Layer node"},{"location":"Overview%20-%20delete%20me/Nodes/#find-and-replace-node","text":"Finds Cells with target Part and replaces the target part with the newPart on them. Parameters : target - part which we want to replace newPart - part which will replace","title":"Find And Replace Node"},{"location":"Overview%20-%20delete%20me/Nodes/#extract-positions-node","text":"The Extract Positions node extracts positions of input node to the output positions array.","title":"Extract Positions Node"},{"location":"Overview%20-%20delete%20me/Nodes/#merge-override-skin-layers-node","text":"The Merge Override Skin Layers node merges input layers to one layer.","title":"Merge Override Skin Layers Node"},{"location":"Overview%20-%20delete%20me/Nodes/#shift-node","text":"The Shift node shifts positions for all input cells. Parameters: X - x axis offset Y - y axis offset Floor - floor offset","title":"Shift Node"},{"location":"Overview%20-%20delete%20me/Nodes/#split-into-rooms-node","text":"The Split Into Rooms node splits input cells to rooms by overriding their roomIDs. Strongly Recommended to use before [[Place Interiors node]]. Parameters: Min Size - the minimum possible size of rooms Max Size - the minimum possible size of rooms","title":"Split Into Rooms Node"},{"location":"Overview%20-%20delete%20me/Nodes/#add-nodes","text":"","title":"Add nodes"},{"location":"Overview%20-%20delete%20me/Nodes/#add-part-node","text":"The Add Part node adds a part to the input cells. Before Add Part After Add Part","title":"Add Part Node"},{"location":"Overview%20-%20delete%20me/Nodes/#add-part-to-part-node","text":"The Add Part to Part node filters cells by part and add another part to these cells. Parameters: - target - a [[Part OLD]] which will be used as filter - part - a [[Part OLD]] which will be added to filtered cells - mode - No Rotation - just find cells with target [[Part OLD]] and add new part to them - Rotate Only Target - find cells with all possible target rotations and add new part to them - Rotate Target And Part - sync target part and new part rotations. Before After","title":"Add Part to Part Node"},{"location":"Overview%20-%20delete%20me/Nodes/#add-roof-cells-node","text":"The Add Roof Cells node adds additional cells in tops of input cells. Result looks like a pyramid. Before After","title":"Add Roof Cells Node"},{"location":"Overview%20-%20delete%20me/Nodes/#filter-nodes","text":"","title":"Filter nodes"},{"location":"Overview%20-%20delete%20me/Nodes/#filter-by-added-floors-node","text":"The Filter By Added Floors node filters cells which positioned on the floors which wasn't described in the Floors House Generator menu. Parameters: Invert - return cells without added floors.","title":"Filter By Added Floors Node"},{"location":"Overview%20-%20delete%20me/Nodes/#filter-by-floor-node","text":"The Filter By Floor node filters cells positioned on the target floor. Parameters: int field - floor which you want to filter","title":"Filter By Floor Node"},{"location":"Overview%20-%20delete%20me/Nodes/#filter-by-mask-node","text":"The Filter By Mask node returns cells filtered by special mask. Parameters: Mask - a mask which you want to use as filter","title":"Filter By Mask Node"},{"location":"Overview%20-%20delete%20me/Nodes/#filter-by-positions-node","text":"The Filter By Positions node returns cells which has the same positions as in input Positions array.","title":"Filter By Positions Node"},{"location":"Overview%20-%20delete%20me/Nodes/#filter-by-tag-node","text":"The FiIter By Tag node returns cells with target Tag. Input: In - all cells which we want to filter Positions - cells positions array which we want to use as a filter","title":"Filter By Tag Node"},{"location":"Overview%20-%20delete%20me/Nodes/#filter-internel-doors-places-node","text":"The Filter By Internal Doors Places analyzes input cells and returns suitable cellses for doors between rooms. Output: Forward - Cells where you should add the door part which shouldn't be rotated Backward - Cells where you should add the door part which should be rotated by 180 degress. Right - Cells where you should add the door part which should be rotated by 90 degress. Left - Cells where you should add the door part which should be rotated by 270 degress.","title":"Filter Internel Doors Places Node"},{"location":"Overview%20-%20delete%20me/Nodes/#filter-intersetions-node","text":"The Filter Intersections node returns cells whose positions intersect, so if you have cells set with positions [0, 0, 0] , [0, 1, 0], [1, 1, 0] and [3, 4, 0], [0, 0, 0] , [1, 1, 0] , [3, 4, 1], the result will be -> [0, 0, 0] , [1, 1, 0] .","title":"Filter Interse\u0441tions Node"},{"location":"Overview%20-%20delete%20me/Nodes/#filter-neighbour-cells-node","text":"The Filter Neighbour Cells node returns neighbour cells sorted by directions.","title":"Filter Neighbour Cells Node"},{"location":"Overview%20-%20delete%20me/Nodes/#filter-random-cell-node","text":"The Filter Random Cell node returns a random cell from input cells.","title":"Filter Random Cell Node"},{"location":"Overview%20-%20delete%20me/Nodes/#filter-random-input-node","text":"The Filter Random Input node returns cells from a random input.","title":"Filter Random Input Node"},{"location":"Overview%20-%20delete%20me/Nodes/#filter-with-part-node","text":"The Filter With Part node returns cells with a target part.","title":"Filter With Part Node"},{"location":"Overview%20-%20delete%20me/Nodes/#filter-without-part-node","text":"The Filter Without Part node returns cells without a target part.","title":"Filter Without Part Node"},{"location":"Overview%20-%20delete%20me/Nodes/#flow","text":"","title":"Flow"},{"location":"Overview%20-%20delete%20me/Nodes/#exclude-node","text":"The Exclude node returns cells from A input but without cells from B input.","title":"Exclude Node"},{"location":"Overview%20-%20delete%20me/Nodes/#merge-node","text":"The Merge node merges cells from input into one cells set (parts sets also will be merged) and then returns them.","title":"Merge Node"},{"location":"Overview%20-%20delete%20me/Nodes/#override-node","text":"The Override node merges input cells into one cells set, but intersected cells from an A input will be overrode by cells from a B input.","title":"Override Node"},{"location":"Overview%20-%20delete%20me/Nodes/#shuffle-node","text":"The Shuffle node shuffles an input cells array. That's not change cells positions or other sort of data, it just makes a chaotic reordering of an input cells set.","title":"Shuffle Node"},{"location":"Overview%20-%20delete%20me/Nodes/#main-nodes","text":"","title":"Main Nodes"},{"location":"Overview%20-%20delete%20me/Nodes/#end-node","text":"The End node returns an input cells as a result of Pipeline working. The Pipeline should always have one (and only one) End node or it'll not working properly. You can also use this node for debugging, just connect an input of this node with output of some node to see that's happening in this step of generation.","title":"End Node"},{"location":"Overview%20-%20delete%20me/Nodes/#start-node","text":"The Start node is an entry point of generation process. This node collects data stored in the House Generator component and use them to make a house draft. The Start node returns a set of cells which represents a gabarits of house, but these cells has no parts, they aren't splitted by rooms and so on. That's just raw cells.","title":"Start Node"},{"location":"Overview%20-%20delete%20me/Nodes/#place-nodes","text":"","title":"Place Nodes"},{"location":"Overview%20-%20delete%20me/Nodes/#place-interiors-node","text":"The Place Interiors node analysis input cells and sets a relevent interior for them. It also places furniture.","title":"Place Interiors Node"},{"location":"Overview%20-%20delete%20me/Nodes/#place-part-node","text":"The Place Part node filters cells by mask and add a [[Part OLD]] to them.","title":"Place Part Node"},{"location":"Overview%20-%20delete%20me/Nodes/#place-placeable-object-forced-node","text":"Unlike Place Placeable Object node, this node ignores placing requirements and just place this Placeable Object on input cell. Input : All - all accessible cells, needs to run actions after placing (read Placeable Object OLD ). Target - here you want to place this PlaceableObject. Parameters : placeableObject - a Placeable Object which you want to place turn - how you want to turn it when placing","title":"Place Placeable Object Forced Node"},{"location":"Overview%20-%20delete%20me/Nodes/#place-placeable-object-node","text":"The Place Placeable Object node places a PlaceableObject ot input cells. Parameters: Placing Mode: One Per House - try to place Placeable Object only once. One Per Floor - try to place Placeable Object once on every accessible floor. One Per Room - try to place Placeable Object once on every room. One Per Cell - try to place Placeable Object on every input cell.","title":"Place Placeable Object Node"},{"location":"Overview%20-%20delete%20me/Nodes/#place-stairs-node","text":"The Place Stairs node tires to place stairs in the longest stairwells. Your house can have more than one stairwell, mostly because of difference between floors planning. Cells of floors which wasn't successfully connected returns to the Failed output, so you can handle them by less demanding rules. input: In - cells to process Forbidden - cells which inaccessible for stairs placing output: Successful - cells of floors which was connected by placed stairs. Failed - cells of floors which wasn't connected by stairwell parameters: stairs - a Placeable Object which represents stairs minStairwellLenght - minimal length of stairwell","title":"Place Stairs Node"},{"location":"Overview%20-%20delete%20me/Nodes/#remove-nodes","text":"","title":"Remove Nodes"},{"location":"Overview%20-%20delete%20me/Nodes/#remove-part-node","text":"The Remove Part node removes a part from all input cells.","title":"Remove Part Node"},{"location":"Overview%20-%20delete%20me/Parts%20Binding%20System%20OLD/","text":"Parts Binding System \u00b6 The easiest way to understand how to use the Parts Binding System is just looks to it in action. As you can see in screenshot above we have a list with pairs of objects. It's a binding list. Let's take a closer look at the binding element: Reference to the [[Part Builder OLD]]. Reference to relevant [[Part OLD]]. Rotation offset . Note Please note that they have the same names. It's a very important detail. In process of generation the House Builder tries to find a relevant look to the [[Part OLD]], so it asks every accessible skin if they have some look to the current [[Part OLD]]. Look is a [[Part Builder OLD]] as you might have guessed. And [[Skin OLD]] answers him something like \"Yey, I have one, take this ([[Part Builder OLD]] and then rotate it by ( Rotation offset )\". That's how it works. But how to use it? Well, here are several ways to do it. Manual Binding \u00b6 The easiest way is just add new binding element and drag'n'drop relevant [[Part OLD]] and [[Part Builder OLD]], and write a rotation offset. But I don't recommend it because it makes workflow too tiring. Instead of it I definitely recommend to use an Auto Binding . Auto Binding \u00b6 Auto Binding is a much faster way to work with Skin. You don't need to add binding pairs manually, instead of it you must comply the PartBuilders namin convention . PartBuilders naming convention \u00b6 Part and PartBuilder names should be the same. If you want to add some special rotation you shall write it in square brackets. Example [90] Internal Wall If PartBuilder should have 4 standard rotations (0, 90, 180, 270) you must write [auto] name prefix Example [auto] Internal Wall If you want to change a look of some object turn separately, you can make an [auto] PartBuilder for the general rotations and one with [special rotation] for your special case. Example [auto] Internal Wall - with regular wallpapers [180] Internal Wall - with dirty wallpapers In process of binding [[Skin OLD]] tries to find a part with the same name as current [[Part Builder OLD]]. If it's found, it makes a new binding pair, else there are two scenarious: Ignore this [[Part Builder OLD]] Make new [[Part OLD]] for this [[Part Builder OLD]]. To find out how to select what to do with unbound PartBuilders read below. If [[Part Builder OLD]] has an [auto] prefix, Binding System will try to find 4 Parts with [0] , [90] , [180] and [270] prefixes. Result will looks like that: As you can see here we have 4 references to the same [[Part Builder OLD]], but with different Parts, and we also have relevant rotation offsets for them. Binding Panel \u00b6 Now it's time to show how to apply changes. An Auto Binding panel look Create Parts for unbound? - if true Skin will create new Parts for failed PartBuilders. Path for new Parts. Change Folder - press it to change a path for new Parts Update Binding - click it to apply PartBuilding changes.","title":"Parts Binding System"},{"location":"Overview%20-%20delete%20me/Parts%20Binding%20System%20OLD/#parts-binding-system","text":"The easiest way to understand how to use the Parts Binding System is just looks to it in action. As you can see in screenshot above we have a list with pairs of objects. It's a binding list. Let's take a closer look at the binding element: Reference to the [[Part Builder OLD]]. Reference to relevant [[Part OLD]]. Rotation offset . Note Please note that they have the same names. It's a very important detail. In process of generation the House Builder tries to find a relevant look to the [[Part OLD]], so it asks every accessible skin if they have some look to the current [[Part OLD]]. Look is a [[Part Builder OLD]] as you might have guessed. And [[Skin OLD]] answers him something like \"Yey, I have one, take this ([[Part Builder OLD]] and then rotate it by ( Rotation offset )\". That's how it works. But how to use it? Well, here are several ways to do it.","title":"Parts Binding System"},{"location":"Overview%20-%20delete%20me/Parts%20Binding%20System%20OLD/#manual-binding","text":"The easiest way is just add new binding element and drag'n'drop relevant [[Part OLD]] and [[Part Builder OLD]], and write a rotation offset. But I don't recommend it because it makes workflow too tiring. Instead of it I definitely recommend to use an Auto Binding .","title":"Manual Binding"},{"location":"Overview%20-%20delete%20me/Parts%20Binding%20System%20OLD/#auto-binding","text":"Auto Binding is a much faster way to work with Skin. You don't need to add binding pairs manually, instead of it you must comply the PartBuilders namin convention .","title":"Auto Binding"},{"location":"Overview%20-%20delete%20me/Parts%20Binding%20System%20OLD/#partbuilders-naming-convention","text":"Part and PartBuilder names should be the same. If you want to add some special rotation you shall write it in square brackets. Example [90] Internal Wall If PartBuilder should have 4 standard rotations (0, 90, 180, 270) you must write [auto] name prefix Example [auto] Internal Wall If you want to change a look of some object turn separately, you can make an [auto] PartBuilder for the general rotations and one with [special rotation] for your special case. Example [auto] Internal Wall - with regular wallpapers [180] Internal Wall - with dirty wallpapers In process of binding [[Skin OLD]] tries to find a part with the same name as current [[Part Builder OLD]]. If it's found, it makes a new binding pair, else there are two scenarious: Ignore this [[Part Builder OLD]] Make new [[Part OLD]] for this [[Part Builder OLD]]. To find out how to select what to do with unbound PartBuilders read below. If [[Part Builder OLD]] has an [auto] prefix, Binding System will try to find 4 Parts with [0] , [90] , [180] and [270] prefixes. Result will looks like that: As you can see here we have 4 references to the same [[Part Builder OLD]], but with different Parts, and we also have relevant rotation offsets for them.","title":"PartBuilders naming convention"},{"location":"Overview%20-%20delete%20me/Parts%20Binding%20System%20OLD/#binding-panel","text":"Now it's time to show how to apply changes. An Auto Binding panel look Create Parts for unbound? - if true Skin will create new Parts for failed PartBuilders. Path for new Parts. Change Folder - press it to change a path for new Parts Update Binding - click it to apply PartBuilding changes.","title":"Binding Panel"},{"location":"Overview%20-%20delete%20me/Place%20OLD/","text":"Place \u00b6 Place is a describing system. It represents some place in the house, so you can use it to describe where you want to place some stuff, or you can filter cells which looks like what you described and do something with them and so on. Preview system handles Place, so you can see all changes instantly Place is a set of cells, so if you want to describe some place you should select cells which you want to check, active enable checkbox and add all parts which this place should have into Par In example above described a room corner. Please note what there are no facade sides of walls, what's because this place uses mostly to place furniture, so we don't care about external look of the house. It works because an internal side of the house (include place furniture step also) generates separately from external. How to... \u00b6 To make a new place select some folder and click right mouse button -> Create -> Domik -> Place To make a place with multiple cells select several cells and active an enable checkbox To add some cells on another room select it in the Floor popup menu","title":"Place"},{"location":"Overview%20-%20delete%20me/Place%20OLD/#place","text":"Place is a describing system. It represents some place in the house, so you can use it to describe where you want to place some stuff, or you can filter cells which looks like what you described and do something with them and so on. Preview system handles Place, so you can see all changes instantly Place is a set of cells, so if you want to describe some place you should select cells which you want to check, active enable checkbox and add all parts which this place should have into Par In example above described a room corner. Please note what there are no facade sides of walls, what's because this place uses mostly to place furniture, so we don't care about external look of the house. It works because an internal side of the house (include place furniture step also) generates separately from external.","title":"Place"},{"location":"Overview%20-%20delete%20me/Place%20OLD/#how-to","text":"To make a new place select some folder and click right mouse button -> Create -> Domik -> Place To make a place with multiple cells select several cells and active an enable checkbox To add some cells on another room select it in the Floor popup menu","title":"How to..."},{"location":"Overview%20-%20delete%20me/Placeable%20Object%20OLD/","text":"Placeable Object \u00b6 Placeable Object is, basically, a [[Part OLD]] with info where you want to place it. Mostly uses for furniture, but you can use it even for place walls or something else. Preview handles a placeable object automatically, so you can see changes instantly. Part - reference to the [[Part OLD]] which you want to place somewhere. Find By - what you want to use to find a better place for this part? Place - use Place OLD Mask - use Mask Reference to Place or Mask Please not that you don't wan't to make a Placeable Object for every rotations of [[Part OLD]]. [[Part OLD]] will be rotated automatically depending on found place. If [[Part OLD]] didn't rotated check [[Part OLD]] rotation references. Actions after placing \u00b6 Sometimes you need to change placed Part environment. To do it select cell which you want to change and add Parts to remove parts list and add parts list. In the preview you'll see removed and","title":"Placeable Object"},{"location":"Overview%20-%20delete%20me/Placeable%20Object%20OLD/#placeable-object","text":"Placeable Object is, basically, a [[Part OLD]] with info where you want to place it. Mostly uses for furniture, but you can use it even for place walls or something else. Preview handles a placeable object automatically, so you can see changes instantly. Part - reference to the [[Part OLD]] which you want to place somewhere. Find By - what you want to use to find a better place for this part? Place - use Place OLD Mask - use Mask Reference to Place or Mask Please not that you don't wan't to make a Placeable Object for every rotations of [[Part OLD]]. [[Part OLD]] will be rotated automatically depending on found place. If [[Part OLD]] didn't rotated check [[Part OLD]] rotation references.","title":"Placeable Object"},{"location":"Overview%20-%20delete%20me/Placeable%20Object%20OLD/#actions-after-placing","text":"Sometimes you need to change placed Part environment. To do it select cell which you want to change and add Parts to remove parts list and add parts list. In the preview you'll see removed and","title":"Actions after placing"},{"location":"WTF/How%20to%20make%20a%20place/","text":"How to make a place \u00b6 At this tutorial I'll show you how to describe 1) select some folder and click right mouse button -> Create -> Domik -> Place 2) Now you have a new Place. Select it. 3) In inspector window select some","title":"How to make a place"},{"location":"WTF/How%20to%20make%20a%20place/#how-to-make-a-place","text":"At this tutorial I'll show you how to describe 1) select some folder and click right mouse button -> Create -> Domik -> Place 2) Now you have a new Place. Select it. 3) In inspector window select some","title":"How to make a place"},{"location":"pipeline-nodes/add-part/","text":"Add Part Node \u00b6 The Add Part node adds a selected part to all input cells. Varieties \u00b6 Add Part 2 Node \u00b6 This node uses in situations where you want to reduce the number of Add Part nodes. Basically this node is equivalent to a chain of two Add Part nodes. Add Part 3 Node \u00b6 An equivalent to a chain of three Add Part nodes. Add Part 4 Node \u00b6 An equivalent to a chain of four Add Part nodes. Add Part To Part Node \u00b6 The Add Part to Part node uses in situations where you want to filter all input cells with specific part and add some part to them. - Target - part what you want to use as a filter - Part - part what you want to add to filtered cells - Mode - Part adding mode: - No Rotation - just add a part to filtered cells - Rotate Only Target - include all possible rotations of the target part to the filter - Rotate Target And Part - filter all possible rotations of the target and add relevant rotation offset to the part.","title":"add part"},{"location":"pipeline-nodes/add-part/#add-part-node","text":"The Add Part node adds a selected part to all input cells.","title":"Add Part Node"},{"location":"pipeline-nodes/add-part/#varieties","text":"","title":"Varieties"},{"location":"pipeline-nodes/add-part/#add-part-2-node","text":"This node uses in situations where you want to reduce the number of Add Part nodes. Basically this node is equivalent to a chain of two Add Part nodes.","title":"Add Part 2 Node"},{"location":"pipeline-nodes/add-part/#add-part-3-node","text":"An equivalent to a chain of three Add Part nodes.","title":"Add Part 3 Node"},{"location":"pipeline-nodes/add-part/#add-part-4-node","text":"An equivalent to a chain of four Add Part nodes.","title":"Add Part 4 Node"},{"location":"pipeline-nodes/add-part/#add-part-to-part-node","text":"The Add Part to Part node uses in situations where you want to filter all input cells with specific part and add some part to them. - Target - part what you want to use as a filter - Part - part what you want to add to filtered cells - Mode - Part adding mode: - No Rotation - just add a part to filtered cells - Rotate Only Target - include all possible rotations of the target part to the filter - Rotate Target And Part - filter all possible rotations of the target and add relevant rotation offset to the part.","title":"Add Part To Part Node"},{"location":"pipeline-nodes/apply-parts-removing/","text":"Apply Parts Removing \u00b6 This node applies parts removing requests. Inputs: In - cells to clean up Remove - parts removing requests which you want to apply Outputs: Out - result Examples \u00b6 A wonderful example of using is showed in the remove part later article.","title":"apply parts removing"},{"location":"pipeline-nodes/apply-parts-removing/#apply-parts-removing","text":"This node applies parts removing requests. Inputs: In - cells to clean up Remove - parts removing requests which you want to apply Outputs: Out - result","title":"Apply Parts Removing"},{"location":"pipeline-nodes/apply-parts-removing/#examples","text":"A wonderful example of using is showed in the remove part later article.","title":"Examples"},{"location":"pipeline-nodes/calculate-room-interiors/","text":"Calculate Room Interiors \u00b6 This node calculates suitable interiors for rooms. You have to return calculated interiors to the END node as it shows below. Inputs: In - cells to analyze Outputs: Room Interiors - suitable interiors for rooms Explain \u00b6 There is no effect of room's calculating if you don't return it to the END node. But what will happen if you return the result of calculations to the END node But... There is furniture? To add furniture you have to use a Place Furniture node. Wait, wait, are these the same interiors? Why did the walls change color? That's because walls materials defined by the skins system, and in this example skins are dynamic. Every room has a bunch of randomly selected skins, and if you used a random engine somewhere before using of the skins, the result of the skins selecting will be different. So yes, these are the same interiors, but with another skins. You can also return calculated room interiors by the Return Interiors node as it shows below.","title":"calculate room interiors"},{"location":"pipeline-nodes/calculate-room-interiors/#calculate-room-interiors","text":"This node calculates suitable interiors for rooms. You have to return calculated interiors to the END node as it shows below. Inputs: In - cells to analyze Outputs: Room Interiors - suitable interiors for rooms","title":"Calculate Room Interiors"},{"location":"pipeline-nodes/calculate-room-interiors/#explain","text":"There is no effect of room's calculating if you don't return it to the END node. But what will happen if you return the result of calculations to the END node But... There is furniture? To add furniture you have to use a Place Furniture node. Wait, wait, are these the same interiors? Why did the walls change color? That's because walls materials defined by the skins system, and in this example skins are dynamic. Every room has a bunch of randomly selected skins, and if you used a random engine somewhere before using of the skins, the result of the skins selecting will be different. So yes, these are the same interiors, but with another skins. You can also return calculated room interiors by the Return Interiors node as it shows below.","title":"Explain"},{"location":"pipeline-nodes/create-skins-layer/","text":"Create Skins Layer \u00b6 This node creates an override skins layer, use it if you want to add some special look for several cells. Inputs: In - cells for which you want to override the look Outputs: Skins Layer - a result data that you have to return to the end node to apply changes Properties: Skin - skin that you want to apply to input cells. Examples \u00b6 In this example we'll change a color of basement floor facade walls. Now let's filter a basement floor. Now we can use filtered cells as a base for the Skins Layer. Apply changes by the Return Skins Layer node.","title":"create skins layer"},{"location":"pipeline-nodes/create-skins-layer/#create-skins-layer","text":"This node creates an override skins layer, use it if you want to add some special look for several cells. Inputs: In - cells for which you want to override the look Outputs: Skins Layer - a result data that you have to return to the end node to apply changes Properties: Skin - skin that you want to apply to input cells.","title":"Create Skins Layer"},{"location":"pipeline-nodes/create-skins-layer/#examples","text":"In this example we'll change a color of basement floor facade walls. Now let's filter a basement floor. Now we can use filtered cells as a base for the Skins Layer. Apply changes by the Return Skins Layer node.","title":"Examples"},{"location":"pipeline-nodes/end/","text":"End \u00b6 An End node is a final node of the pipeline. You should have one to work with the Pipeline properly. Inputs: Cells - cells to be built Override Skin Layers - cells which should have special skin instead of own.","title":"end"},{"location":"pipeline-nodes/end/#end","text":"An End node is a final node of the pipeline. You should have one to work with the Pipeline properly. Inputs: Cells - cells to be built Override Skin Layers - cells which should have special skin instead of own.","title":"End"},{"location":"pipeline-nodes/exclude/","text":"Exclude \u00b6 This node excludes cells B from cells A. Inputs: A - cells which you want to process B - cells which you want to exclude from A Outputs: Out - result Examples \u00b6 Input is a house that has been completed. Now let's filter facade. Now we can exclude it from the main cells flow.","title":"exclude"},{"location":"pipeline-nodes/exclude/#exclude","text":"This node excludes cells B from cells A. Inputs: A - cells which you want to process B - cells which you want to exclude from A Outputs: Out - result","title":"Exclude"},{"location":"pipeline-nodes/exclude/#examples","text":"Input is a house that has been completed. Now let's filter facade. Now we can exclude it from the main cells flow.","title":"Examples"},{"location":"pipeline-nodes/extract-positions/","text":"Extract Positions \u00b6 This node extract positions of input cells to use them later. Pretty useful to save positions of some processed cells. Inputs: Cells - cells to extract Outputs: Positions - extracted positions Examples \u00b6 A good example of using this node is showed here: filter by positions","title":"extract positions"},{"location":"pipeline-nodes/extract-positions/#extract-positions","text":"This node extract positions of input cells to use them later. Pretty useful to save positions of some processed cells. Inputs: Cells - cells to extract Outputs: Positions - extracted positions","title":"Extract Positions"},{"location":"pipeline-nodes/extract-positions/#examples","text":"A good example of using this node is showed here: filter by positions","title":"Examples"},{"location":"pipeline-nodes/filter-by-mask/","text":"Filter By Mask \u00b6 Use this node to filter cells by some mask. Inputs: In - cells to filter Outputs: 0 - cells filtered by mask 90 - cells filtered by mask that has been rotated by 90 degrees 180 - cells filtered by mask that has been rotated by 180 degrees 270 - cells filtered by mask that has been rotated by 270 degrees Properties: - Mask - a mask to use as a filter. Examples \u00b6 Input is a house that has been completed. Now lets use a Forward House Borders mask as a filter. Nodes Mask Result Other outputs Mask rotated by 90 degrees Mask rotated by 180 degrees Mask rotated by 270 degrees Merged rotations Merged and inverted","title":"filter by mask"},{"location":"pipeline-nodes/filter-by-mask/#filter-by-mask","text":"Use this node to filter cells by some mask. Inputs: In - cells to filter Outputs: 0 - cells filtered by mask 90 - cells filtered by mask that has been rotated by 90 degrees 180 - cells filtered by mask that has been rotated by 180 degrees 270 - cells filtered by mask that has been rotated by 270 degrees Properties: - Mask - a mask to use as a filter.","title":"Filter By Mask"},{"location":"pipeline-nodes/filter-by-mask/#examples","text":"Input is a house that has been completed. Now lets use a Forward House Borders mask as a filter. Nodes Mask Result Other outputs Mask rotated by 90 degrees Mask rotated by 180 degrees Mask rotated by 270 degrees Merged rotations Merged and inverted","title":"Examples"},{"location":"pipeline-nodes/filter-by-positions/","text":"Filter By Positions \u00b6 This node filters cells by positions. Inputs: In - cells to filter Positions - Positions of cells which should be filtered Outputs: Out - filtered cells Examples \u00b6 Input is a house that has been completed. Now lets extract positions of random cells and use them as a filter.","title":"filter by positions"},{"location":"pipeline-nodes/filter-by-positions/#filter-by-positions","text":"This node filters cells by positions. Inputs: In - cells to filter Positions - Positions of cells which should be filtered Outputs: Out - filtered cells","title":"Filter By Positions"},{"location":"pipeline-nodes/filter-by-positions/#examples","text":"Input is a house that has been completed. Now lets extract positions of random cells and use them as a filter.","title":"Examples"},{"location":"pipeline-nodes/filter-by-tag/","text":"Filter By Tag \u00b6 This node filters nodes by the floor tag . Use this node to filter and process a specific floor. Inputs: In - cells to filter Outputs: Success - filtered cells Failed - unfiltered cells Properties: Floor Tag - a floor tag that will be used as a filter Examples \u00b6 Input is a house that has been completed. Now lets filter a floor with a Roof floor tag. Success output Failed output","title":"filter by tag"},{"location":"pipeline-nodes/filter-by-tag/#filter-by-tag","text":"This node filters nodes by the floor tag . Use this node to filter and process a specific floor. Inputs: In - cells to filter Outputs: Success - filtered cells Failed - unfiltered cells Properties: Floor Tag - a floor tag that will be used as a filter","title":"Filter By Tag"},{"location":"pipeline-nodes/filter-by-tag/#examples","text":"Input is a house that has been completed. Now lets filter a floor with a Roof floor tag. Success output Failed output","title":"Examples"},{"location":"pipeline-nodes/filter-floor/","text":"Filter Floor \u00b6 Use this node to filter concrete floor. Inputs: In - cells to filter Floor - input number (optional). Outputs: Out - filtered cells Properties: Number - Number of the floor to filter Examples \u00b6 Input is a house that has been completed. Now lets filter the first floor","title":"filter floor"},{"location":"pipeline-nodes/filter-floor/#filter-floor","text":"Use this node to filter concrete floor. Inputs: In - cells to filter Floor - input number (optional). Outputs: Out - filtered cells Properties: Number - Number of the floor to filter","title":"Filter Floor"},{"location":"pipeline-nodes/filter-floor/#examples","text":"Input is a house that has been completed. Now lets filter the first floor","title":"Examples"},{"location":"pipeline-nodes/filter-internal-doors-places/","text":"Filter Internal Doors Places \u00b6 This node filters best places for doors between rooms. You have to add parts for all outputs and then merge them together in most situations. Inputs: In - cells to filter Outputs: 0 - cells for door part with original rotation 90 - cells for door part rotated by 90 degrees 180 - cells for door part rotated by 180 degrees 270 - cells for door part rotated by 270 degrees Examples \u00b6 Input is a set of barebone rooms without extarnal walls, windows, furniture etc. Now let's filter best places for doors and look up to the result. Looks... strange and useless. But it's not actually. Let's add a [0] Internal Doorway part to add a more context. Much Better! But now we have a parts overlapping. To solve it we have to remove [0] internal wall parts from filtered cells. Wonderful! Now let's repeat it for other rotations and merge them. Don't use a Remove Part node before the merge node! Don't use a Remove Part node before the merge node! It'll cause artifacts because there is no way to merge removing actions properly. Instead of that use the Remove Part Later and the Apply Parts Removing as it shows below. Still looks like a mess, but we have all doors! Last step - applying changes to the main cells flow.","title":"filter internal doors places"},{"location":"pipeline-nodes/filter-internal-doors-places/#filter-internal-doors-places","text":"This node filters best places for doors between rooms. You have to add parts for all outputs and then merge them together in most situations. Inputs: In - cells to filter Outputs: 0 - cells for door part with original rotation 90 - cells for door part rotated by 90 degrees 180 - cells for door part rotated by 180 degrees 270 - cells for door part rotated by 270 degrees","title":"Filter Internal Doors Places"},{"location":"pipeline-nodes/filter-internal-doors-places/#examples","text":"Input is a set of barebone rooms without extarnal walls, windows, furniture etc. Now let's filter best places for doors and look up to the result. Looks... strange and useless. But it's not actually. Let's add a [0] Internal Doorway part to add a more context. Much Better! But now we have a parts overlapping. To solve it we have to remove [0] internal wall parts from filtered cells. Wonderful! Now let's repeat it for other rotations and merge them. Don't use a Remove Part node before the merge node! Don't use a Remove Part node before the merge node! It'll cause artifacts because there is no way to merge removing actions properly. Instead of that use the Remove Part Later and the Apply Parts Removing as it shows below. Still looks like a mess, but we have all doors! Last step - applying changes to the main cells flow.","title":"Examples"},{"location":"pipeline-nodes/filter-intersections/","text":"Filter Intersections \u00b6 This node filters intersected cells between A and B inputs. Inputs: A - first pool of cells to check intersection B - second pool of cells to check intersection Outputs: Out - result Examples \u00b6 Input is a house that has been completed. Now let's filter these cells by Forward House Borders mask. Now look at the result of mask rotation by 90 degrees. Perfect candidate for finding of cells intersection. Let's find an intersection between cells filtered by 0\u00b0 and by 90\u00b0 rotations of the mask! You can even invert the result by the Exclude node.","title":"filter intersections"},{"location":"pipeline-nodes/filter-intersections/#filter-intersections","text":"This node filters intersected cells between A and B inputs. Inputs: A - first pool of cells to check intersection B - second pool of cells to check intersection Outputs: Out - result","title":"Filter Intersections"},{"location":"pipeline-nodes/filter-intersections/#examples","text":"Input is a house that has been completed. Now let's filter these cells by Forward House Borders mask. Now look at the result of mask rotation by 90 degrees. Perfect candidate for finding of cells intersection. Let's find an intersection between cells filtered by 0\u00b0 and by 90\u00b0 rotations of the mask! You can even invert the result by the Exclude node.","title":"Examples"},{"location":"pipeline-nodes/filter-neighbor-cells/","text":"Filter Neighbor \u00b6 This node filters target neighbor cells. Inputs: All - the main cells flow Target - cells for which you want to find neighbors Outputs: Top - top neighbor cells Bottom - bottom neighbor cells Forward - forward neighbor cells Backward - backward neighbor cells Right - right neighbor cells Left - left neighbor cells Examples \u00b6 Input is a house that has been completed. Let's filter the right side of the house. Now we can slice this house like a pie by using the Filter Neighbor Cells node. Or we can make something mad... Another example: let's select some random cell: Now we can add some cells around: This node is pretty useful for situations when you want to filter some floor. Let's filter the Basement floor by the Filter by Tag node. Now we can filter the top floor by the Filter Neighbor Cells node. Well, now, we can, for example, change the facade look.","title":"filter neighbor cells"},{"location":"pipeline-nodes/filter-neighbor-cells/#filter-neighbor","text":"This node filters target neighbor cells. Inputs: All - the main cells flow Target - cells for which you want to find neighbors Outputs: Top - top neighbor cells Bottom - bottom neighbor cells Forward - forward neighbor cells Backward - backward neighbor cells Right - right neighbor cells Left - left neighbor cells","title":"Filter Neighbor"},{"location":"pipeline-nodes/filter-neighbor-cells/#examples","text":"Input is a house that has been completed. Let's filter the right side of the house. Now we can slice this house like a pie by using the Filter Neighbor Cells node. Or we can make something mad... Another example: let's select some random cell: Now we can add some cells around: This node is pretty useful for situations when you want to filter some floor. Let's filter the Basement floor by the Filter by Tag node. Now we can filter the top floor by the Filter Neighbor Cells node. Well, now, we can, for example, change the facade look.","title":"Examples"},{"location":"pipeline-nodes/filter-random-cells/","text":"Filter Random Cells \u00b6 Use this node to filter random cells Inputs: In - cells to filter Outputs: Success - filtered cells Failed - \u0441ells that have not been filtered Properties: Count - how many cells you want to filter Examples \u00b6 Input is a house that has been completed. Now lets add a Filter Random Cells node. Result: Failed output:","title":"filter random cells"},{"location":"pipeline-nodes/filter-random-cells/#filter-random-cells","text":"Use this node to filter random cells Inputs: In - cells to filter Outputs: Success - filtered cells Failed - \u0441ells that have not been filtered Properties: Count - how many cells you want to filter","title":"Filter Random Cells"},{"location":"pipeline-nodes/filter-random-cells/#examples","text":"Input is a house that has been completed. Now lets add a Filter Random Cells node. Result: Failed output:","title":"Examples"},{"location":"pipeline-nodes/filter-random-input/","text":"Filter Random Input \u00b6 This node filters random input cells flow. Inputs: In - cell inputs to select random flow. Outputs: Out - result Properties: Mode: Single - return only one cells flow Multiple - merge and return several cell flows Examples \u00b6 Input is a house that has been completed. Now let's filter a house border Now we can select a random Filter By Mask node output by the Filter Random Input node. And this is a result of the filtering with a Multiple mode on.","title":"filter random input"},{"location":"pipeline-nodes/filter-random-input/#filter-random-input","text":"This node filters random input cells flow. Inputs: In - cell inputs to select random flow. Outputs: Out - result Properties: Mode: Single - return only one cells flow Multiple - merge and return several cell flows","title":"Filter Random Input"},{"location":"pipeline-nodes/filter-random-input/#examples","text":"Input is a house that has been completed. Now let's filter a house border Now we can select a random Filter By Mask node output by the Filter Random Input node. And this is a result of the filtering with a Multiple mode on.","title":"Examples"},{"location":"pipeline-nodes/filter-with-part/","text":"Filter With Part \u00b6 This node allows you to filter cells which contains some part. Inputs: In - cells to filter Outputs: Success - cells with a target Part Failed - cells without a target Part Properties: Part - part what will be used as a filter Examples \u00b6 Input is a house that has been completed. Now we can filter all cells with an Audio System without a rotation offset. To filter all rotations use a Filter With Part 4 node with a Filter with Any mode as it shows below","title":"filter with part"},{"location":"pipeline-nodes/filter-with-part/#filter-with-part","text":"This node allows you to filter cells which contains some part. Inputs: In - cells to filter Outputs: Success - cells with a target Part Failed - cells without a target Part Properties: Part - part what will be used as a filter","title":"Filter With Part"},{"location":"pipeline-nodes/filter-with-part/#examples","text":"Input is a house that has been completed. Now we can filter all cells with an Audio System without a rotation offset. To filter all rotations use a Filter With Part 4 node with a Filter with Any mode as it shows below","title":"Examples"},{"location":"pipeline-nodes/filter-with-parts/","text":"Filter With Parts \u00b6 This node filters cells with several parts. Inputs: In - cells to filter Outputs: Success - filtered cells Properties: Part Fields - targets to filter Filter With: Any - filter cells, which contain any target part. All - filter cells, which contains all target parts. Examples \u00b6 Input is a house that has been completed. Filter With Any Mode \u00b6 This mode is pretty useful for situations when you want to find all variations of some part. In this example we will filter cells with a Bed Segment part with all possible rotations. Filter With All Mode \u00b6 This mode is good when you want to find cells which should looks special. Here we will filter a room corners.","title":"filter with parts"},{"location":"pipeline-nodes/filter-with-parts/#filter-with-parts","text":"This node filters cells with several parts. Inputs: In - cells to filter Outputs: Success - filtered cells Properties: Part Fields - targets to filter Filter With: Any - filter cells, which contain any target part. All - filter cells, which contains all target parts.","title":"Filter With Parts"},{"location":"pipeline-nodes/filter-with-parts/#examples","text":"Input is a house that has been completed.","title":"Examples"},{"location":"pipeline-nodes/filter-with-parts/#filter-with-any-mode","text":"This mode is pretty useful for situations when you want to find all variations of some part. In this example we will filter cells with a Bed Segment part with all possible rotations.","title":"Filter With Any Mode"},{"location":"pipeline-nodes/filter-with-parts/#filter-with-all-mode","text":"This mode is good when you want to find cells which should looks special. Here we will filter a room corners.","title":"Filter With All Mode"},{"location":"pipeline-nodes/filter-without-part/","text":"Filter Without Part \u00b6 This node allows you to filter cells without some part. Inputs: In - cells to filter Outputs: Out - cells without a target Part Properties: Part - part what you want to use as exclude filter Examples \u00b6 Input is a house that has been completed. Now let's exclude cells with a yellow facade.","title":"filter without part"},{"location":"pipeline-nodes/filter-without-part/#filter-without-part","text":"This node allows you to filter cells without some part. Inputs: In - cells to filter Outputs: Out - cells without a target Part Properties: Part - part what you want to use as exclude filter","title":"Filter Without Part"},{"location":"pipeline-nodes/filter-without-part/#examples","text":"Input is a house that has been completed. Now let's exclude cells with a yellow facade.","title":"Examples"},{"location":"pipeline-nodes/find-and-replace/","text":"Find And Replace \u00b6 This node allows you to replace some part with other part. It'll try to process replacing for all rotations of target cells if it's possible. Inputs: In - cells to process replacing Outputs: Out - result of replacing Properties: Target - part to replace New Part - part to use as replace Examples \u00b6 For this example we'll change a facade of complete house. Now we'll replace a thin window walls with a regular window walls by the Find And Replace node.","title":"find and replace"},{"location":"pipeline-nodes/find-and-replace/#find-and-replace","text":"This node allows you to replace some part with other part. It'll try to process replacing for all rotations of target cells if it's possible. Inputs: In - cells to process replacing Outputs: Out - result of replacing Properties: Target - part to replace New Part - part to use as replace","title":"Find And Replace"},{"location":"pipeline-nodes/find-and-replace/#examples","text":"For this example we'll change a facade of complete house. Now we'll replace a thin window walls with a regular window walls by the Find And Replace node.","title":"Examples"},{"location":"pipeline-nodes/merge/","text":"Merge \u00b6 This node merges input cells together. Inputs: In - cells to merge. Multiple input is accessible (obviously) Outputs: Out - merge result Don't use a Remove Part node before the merge node! Don't use a Remove Part node before the merge node! It'll cause artifacts because there is no way to merge removing actions properly. Instead of that use the Remove Part Later and the Apply Parts Removing as it shows below. Wrong: Good: Examples \u00b6 Input is a house that has been completed. Let's filter house corners by the Forward Right House Corners mask. That's how result looks if we were select a 90 degree output. Now we can merge all mask rotations together to get all corners of the house.","title":"merge"},{"location":"pipeline-nodes/merge/#merge","text":"This node merges input cells together. Inputs: In - cells to merge. Multiple input is accessible (obviously) Outputs: Out - merge result Don't use a Remove Part node before the merge node! Don't use a Remove Part node before the merge node! It'll cause artifacts because there is no way to merge removing actions properly. Instead of that use the Remove Part Later and the Apply Parts Removing as it shows below. Wrong: Good:","title":"Merge"},{"location":"pipeline-nodes/merge/#examples","text":"Input is a house that has been completed. Let's filter house corners by the Forward Right House Corners mask. That's how result looks if we were select a 90 degree output. Now we can merge all mask rotations together to get all corners of the house.","title":"Examples"},{"location":"pipeline-nodes/override-skins-layer/","text":"Override Skins Layer \u00b6 This node allows you to combine two Skins Layer flows together. Inputs: A - a skins layer flow that will be overriden. B - a skins layer flow that will override an A flow. Outputs: Result - a result of overriding A flow by the B flow. Examples \u00b6 In this example we'll repaint facades of completed house. Now we'll create two skins layer flows and combine them together by overriding","title":"override skins layer"},{"location":"pipeline-nodes/override-skins-layer/#override-skins-layer","text":"This node allows you to combine two Skins Layer flows together. Inputs: A - a skins layer flow that will be overriden. B - a skins layer flow that will override an A flow. Outputs: Result - a result of overriding A flow by the B flow.","title":"Override Skins Layer"},{"location":"pipeline-nodes/override-skins-layer/#examples","text":"In this example we'll repaint facades of completed house. Now we'll create two skins layer flows and combine them together by overriding","title":"Examples"},{"location":"pipeline-nodes/override/","text":"Override \u00b6 This node overrides cells A with cells B . Overriding process will replace A cells with B cells with the same position. Most often used in situations where you have filtered cells to a separate flow, changed them, and now want to apply the changes to the main flow. Inputs: A - cells flow which you want to override B - cells that will override Outputs: Out - overriding result Examples \u00b6 Input is a house that has been completed. Let's remove windows from yellow walls by the Find and Replace node. Now we can apply changes to the main flow by the Override node. Interesting Case \u00b6 In this example we will see an interesting point of cells overriding. To do this, we must shift the top floor up. Let's filter roof cells by the Flat Roof Places node. Now let's shift it up by the Shift node. Now let's apply changes by the overriding node. Very strange result! It looks like, instead of moving, we just copied and pasted the top floor. The override node works pretty similar to the Merge Node but with one exception - instead of merging overlapped cells it just replace it with new. In this example, there is no overlapped cells, so top floor cells just added to the house as a bunch of new cells. How to solve it? Just exclude a filtered floor!","title":"override"},{"location":"pipeline-nodes/override/#override","text":"This node overrides cells A with cells B . Overriding process will replace A cells with B cells with the same position. Most often used in situations where you have filtered cells to a separate flow, changed them, and now want to apply the changes to the main flow. Inputs: A - cells flow which you want to override B - cells that will override Outputs: Out - overriding result","title":"Override"},{"location":"pipeline-nodes/override/#examples","text":"Input is a house that has been completed. Let's remove windows from yellow walls by the Find and Replace node. Now we can apply changes to the main flow by the Override node.","title":"Examples"},{"location":"pipeline-nodes/override/#interesting-case","text":"In this example we will see an interesting point of cells overriding. To do this, we must shift the top floor up. Let's filter roof cells by the Flat Roof Places node. Now let's shift it up by the Shift node. Now let's apply changes by the overriding node. Very strange result! It looks like, instead of moving, we just copied and pasted the top floor. The override node works pretty similar to the Merge Node but with one exception - instead of merging overlapped cells it just replace it with new. In this example, there is no overlapped cells, so top floor cells just added to the house as a bunch of new cells. How to solve it? Just exclude a filtered floor!","title":"Interesting Case"},{"location":"pipeline-nodes/place-furniture/","text":"Place Furniture \u00b6 This node places interior furniture to input cells. Inputs: In - cells to place furniture Room Interiors - An info about rooms of interiors. To calculate it use a Calculate Room Interiors node. Outputs: Out - result Read this to find out how to... Add look for furniture - [[Furniture]] Create new furniture - Placeable Object Add furniture to the interior - [[Interiors]] Examples \u00b6 In this example we will use precalculated cells with empty rooms Now let's calculate Rooms Interiors to know what interior should be for every room. And now we can add furniture","title":"place furniture"},{"location":"pipeline-nodes/place-furniture/#place-furniture","text":"This node places interior furniture to input cells. Inputs: In - cells to place furniture Room Interiors - An info about rooms of interiors. To calculate it use a Calculate Room Interiors node. Outputs: Out - result Read this to find out how to... Add look for furniture - [[Furniture]] Create new furniture - Placeable Object Add furniture to the interior - [[Interiors]]","title":"Place Furniture"},{"location":"pipeline-nodes/place-furniture/#examples","text":"In this example we will use precalculated cells with empty rooms Now let's calculate Rooms Interiors to know what interior should be for every room. And now we can add furniture","title":"Examples"},{"location":"pipeline-nodes/place-part-by-mask-for-all-rotations/","text":"Place Part By Mask For All Rotations \u00b6 This node allows you to find places by the mask and place a Part there. It'll process placing for all four rotations, so it's pretty useful if you want to place something somewhere and you don't care about specific rotations. And yeah, it'll place this part for every found suitable place. Inputs: In - cells there you want to place a part Outputs: Out - placing result Properties: Part - Part that you want to place Mask - Mask that represents a place there you want to place a Part . Examples \u00b6 For this example we will generate a house basic cells, split it by rooms, add floor parts and calculate interiors. Now let's add some walls here! To do it we'll use a Place Part By Mask For All Rotations node with a Forward Rooms Borders mask. This is an alternative way to do the same thing:","title":"place part by mask for all rotations"},{"location":"pipeline-nodes/place-part-by-mask-for-all-rotations/#place-part-by-mask-for-all-rotations","text":"This node allows you to find places by the mask and place a Part there. It'll process placing for all four rotations, so it's pretty useful if you want to place something somewhere and you don't care about specific rotations. And yeah, it'll place this part for every found suitable place. Inputs: In - cells there you want to place a part Outputs: Out - placing result Properties: Part - Part that you want to place Mask - Mask that represents a place there you want to place a Part .","title":"Place Part By Mask For All Rotations"},{"location":"pipeline-nodes/place-part-by-mask-for-all-rotations/#examples","text":"For this example we will generate a house basic cells, split it by rooms, add floor parts and calculate interiors. Now let's add some walls here! To do it we'll use a Place Part By Mask For All Rotations node with a Forward Rooms Borders mask. This is an alternative way to do the same thing:","title":"Examples"},{"location":"pipeline-nodes/place-placeable-object-forced/","text":"Place Placeable Object Forced \u00b6 This node is an alternative to Add Part Node , but, unlike it, it applies changes to the surrounding space. Inputs: All - the main cells flow Target - cells in that you want to place a placeable object Outputs: Out - placing result Properties: Placeable Object - a placeable object that you want to place Turn - force turning Examples \u00b6 For this example we'll use a very simple house blank. Let's imagine that we want to place some stairs in a specific cell. That will happens if you'll use an Add Part node? Well... something like that. Looks totally wrong, that's because we are not removed internal walls, ceiling and floor on the top floor. We can remove them by the Remove Part node, or... we can just apply Placeable Object actions! To do it we have to use a Place Placeable Object Forced . We already have a preconfigurated Stairs Placeable Object, so let's use it. And we can even rotate it if we want.","title":"place placeable object forced"},{"location":"pipeline-nodes/place-placeable-object-forced/#place-placeable-object-forced","text":"This node is an alternative to Add Part Node , but, unlike it, it applies changes to the surrounding space. Inputs: All - the main cells flow Target - cells in that you want to place a placeable object Outputs: Out - placing result Properties: Placeable Object - a placeable object that you want to place Turn - force turning","title":"Place Placeable Object Forced"},{"location":"pipeline-nodes/place-placeable-object-forced/#examples","text":"For this example we'll use a very simple house blank. Let's imagine that we want to place some stairs in a specific cell. That will happens if you'll use an Add Part node? Well... something like that. Looks totally wrong, that's because we are not removed internal walls, ceiling and floor on the top floor. We can remove them by the Remove Part node, or... we can just apply Placeable Object actions! To do it we have to use a Place Placeable Object Forced . We already have a preconfigurated Stairs Placeable Object, so let's use it. And we can even rotate it if we want.","title":"Examples"},{"location":"pipeline-nodes/place-placeable-object/","text":"Place Placeable Object \u00b6 This node places a PlaceableObject or PlaceableObjectsContainer to input cells. Inputs: In - cells to place. Outputs: Out - placing result. Properties: Placing Mode: Once Per House - try to place this Placeable Object only once somewhere into the house. Once Per Floor - try to place this Placeable Object once per floor. Once Per Room - try to place this Placeable Object in every room. In Every Cell - try to place this Placeable Object in every input cell. A Placeable - placeable object or placeable objects container what you want to place. Examples \u00b6 For this examples we'll use generated rooms without anything as it shows below. Now let's add a Chilling Small Section placeable object with different placing rules. Once Per Cell With this parameter node will try to place a PlaceableObject on every cell. Once Per Room With this parameter node will try to place a PlaceableObject only once per room. Once Per Floor With this parameter node will try to place a PlaceableObject only once per floor. The result of selecting this parameter pretty hard to show, because there is only one chilling section per floor now. Once Per House With this parameter node will try to place a PlaceableObject only once per house. Now it's even harder because there is only one place where this Placeable Object can be. There is no necessary to use a main cells flow as an input, you can filter some bunch of cells and place some PlaceableObject there, just don't forget to override a main cells flow after that. Let's filter several random cells. Now let's place things on them. And now we can apply it to the main cells flow.","title":"place placeable object"},{"location":"pipeline-nodes/place-placeable-object/#place-placeable-object","text":"This node places a PlaceableObject or PlaceableObjectsContainer to input cells. Inputs: In - cells to place. Outputs: Out - placing result. Properties: Placing Mode: Once Per House - try to place this Placeable Object only once somewhere into the house. Once Per Floor - try to place this Placeable Object once per floor. Once Per Room - try to place this Placeable Object in every room. In Every Cell - try to place this Placeable Object in every input cell. A Placeable - placeable object or placeable objects container what you want to place.","title":"Place Placeable Object"},{"location":"pipeline-nodes/place-placeable-object/#examples","text":"For this examples we'll use generated rooms without anything as it shows below. Now let's add a Chilling Small Section placeable object with different placing rules. Once Per Cell With this parameter node will try to place a PlaceableObject on every cell. Once Per Room With this parameter node will try to place a PlaceableObject only once per room. Once Per Floor With this parameter node will try to place a PlaceableObject only once per floor. The result of selecting this parameter pretty hard to show, because there is only one chilling section per floor now. Once Per House With this parameter node will try to place a PlaceableObject only once per house. Now it's even harder because there is only one place where this Placeable Object can be. There is no necessary to use a main cells flow as an input, you can filter some bunch of cells and place some PlaceableObject there, just don't forget to override a main cells flow after that. Let's filter several random cells. Now let's place things on them. And now we can apply it to the main cells flow.","title":"Examples"},{"location":"pipeline-nodes/place-stairs/","text":"Place Stairs \u00b6 This node provides a placing of stairs. Inputs: All - the main cells flow Target - cells where you want to place stairs Forbidden - cells that are forbidden to change Outputs: Out - floor cells that are now connected by stairs Failed - floor cells that have not been connected Properties: Stairs - a placeable object of stairs Min Stairwell Length - a minimal length of the stairwell, low number makes this stairs less realistic but more universal. Examples \u00b6 For this example we'll use a house without interiors, furniture and facades, because the Place Stairs Node designed to be used before calculating and applying interiors. Now we'll try to place a Stairs 6x6 by the Place Stairs node. Here we'll use the same cells flow for the All input and for the Target input because we want to try to place a Stairs 6x5 in whole house. Here windows and doors intersect with the stairs and this is not fine. To solve it we have to add cells with them to the Forbidden input. Top First Person Now this is fine. But sometimes the house structure too complicated to be able to use only one stairs, so you have to add more stairs to connect other floors. In the next example we'll generate a house with another SEED. Last 2 floors are not connected no, so we have to fix it. If you want to see not connected floors use a Failed output. To fix it let's try to place less demanding stairs. All cells that were processed by the placing of stairs now has a Busy part, so we can (and should) ignore them by adding them to forbidden cells. We also use a failed output as a target input because we want to place this stairs in not connected floors. A staircase appeared on the back of the house, between the last two floors. Now all floors are connected.","title":"place stairs"},{"location":"pipeline-nodes/place-stairs/#place-stairs","text":"This node provides a placing of stairs. Inputs: All - the main cells flow Target - cells where you want to place stairs Forbidden - cells that are forbidden to change Outputs: Out - floor cells that are now connected by stairs Failed - floor cells that have not been connected Properties: Stairs - a placeable object of stairs Min Stairwell Length - a minimal length of the stairwell, low number makes this stairs less realistic but more universal.","title":"Place Stairs"},{"location":"pipeline-nodes/place-stairs/#examples","text":"For this example we'll use a house without interiors, furniture and facades, because the Place Stairs Node designed to be used before calculating and applying interiors. Now we'll try to place a Stairs 6x6 by the Place Stairs node. Here we'll use the same cells flow for the All input and for the Target input because we want to try to place a Stairs 6x5 in whole house. Here windows and doors intersect with the stairs and this is not fine. To solve it we have to add cells with them to the Forbidden input. Top First Person Now this is fine. But sometimes the house structure too complicated to be able to use only one stairs, so you have to add more stairs to connect other floors. In the next example we'll generate a house with another SEED. Last 2 floors are not connected no, so we have to fix it. If you want to see not connected floors use a Failed output. To fix it let's try to place less demanding stairs. All cells that were processed by the placing of stairs now has a Busy part, so we can (and should) ignore them by adding them to forbidden cells. We also use a failed output as a target input because we want to place this stairs in not connected floors. A staircase appeared on the back of the house, between the last two floors. Now all floors are connected.","title":"Examples"},{"location":"pipeline-nodes/remove-part-later/","text":"Remove Part Later \u00b6 This node collects an information about cells which you want to clear from some part in the future. Inputs: In - cells to clear Outputs: Out - result Properties: Part - part that you want to remove from cells Examples \u00b6 For this example we'll use a simple blanket of the house. Now let's try to place windows. It seems that nothing happened, but if you look at the house from the other side, it becomes clear that internal walls are blocking windows. So let's fix it! The naive way to fix it is just using a Remove Part node. Looks almost good, but there are walls in the corner, although they shouldn't be there. Why? Well... we have the corner cell in the both flows at the same time, so, in process of merging we have two intersected cells with the same position, but one still has left internal wall, and second has right internal wall, so they both add these walls to the final cell when merging. Merging results of removing will always cause artifacts in intersected cells, so don't merge results of removing. But... that to do? Answer is simple. Just remove parts AFTER merging! And exactly for that there are the Remove Parts Later node and the Apply Removing node.","title":"remove part later"},{"location":"pipeline-nodes/remove-part-later/#remove-part-later","text":"This node collects an information about cells which you want to clear from some part in the future. Inputs: In - cells to clear Outputs: Out - result Properties: Part - part that you want to remove from cells","title":"Remove Part Later"},{"location":"pipeline-nodes/remove-part-later/#examples","text":"For this example we'll use a simple blanket of the house. Now let's try to place windows. It seems that nothing happened, but if you look at the house from the other side, it becomes clear that internal walls are blocking windows. So let's fix it! The naive way to fix it is just using a Remove Part node. Looks almost good, but there are walls in the corner, although they shouldn't be there. Why? Well... we have the corner cell in the both flows at the same time, so, in process of merging we have two intersected cells with the same position, but one still has left internal wall, and second has right internal wall, so they both add these walls to the final cell when merging. Merging results of removing will always cause artifacts in intersected cells, so don't merge results of removing. But... that to do? Answer is simple. Just remove parts AFTER merging! And exactly for that there are the Remove Parts Later node and the Apply Removing node.","title":"Examples"},{"location":"pipeline-nodes/remove-part/","text":"Remove Part \u00b6 This node removes a part from cells. Inputs: In - cells in that you want to remove a part Outputs: Out - removing result Properties: Part field - part that you want to remove from cells Examples \u00b6 For this example we'll use a simple blank of the house. In this example we'll select random cells on the last floor and remove some walls from them. Now let's filter the last floor. Next filter random cells. And remove a wall from them. And the final step - applying changes on the main cells flow by the Overriding node. !Note Don't use a Remove Part node before the Merge node! It'll cause artifacts because there is no way to merge removing actions properly. Instead of that use the Remove Part Later and the Apply Parts Removing as it shows below. Wrong: Good:","title":"remove part"},{"location":"pipeline-nodes/remove-part/#remove-part","text":"This node removes a part from cells. Inputs: In - cells in that you want to remove a part Outputs: Out - removing result Properties: Part field - part that you want to remove from cells","title":"Remove Part"},{"location":"pipeline-nodes/remove-part/#examples","text":"For this example we'll use a simple blank of the house. In this example we'll select random cells on the last floor and remove some walls from them. Now let's filter the last floor. Next filter random cells. And remove a wall from them. And the final step - applying changes on the main cells flow by the Overriding node. !Note Don't use a Remove Part node before the Merge node! It'll cause artifacts because there is no way to merge removing actions properly. Instead of that use the Remove Part Later and the Apply Parts Removing as it shows below. Wrong: Good:","title":"Examples"},{"location":"pipeline-nodes/return-interiors/","text":"Return Interiors \u00b6 This node provides an alternative way to apply calculated rooms interiors. Use it if you want to make your pipeline structure cleaner. Inputs: Room Interiors - Room Interiors which you want to return to the End node Examples \u00b6 These two methods give the same result. Return by the End node Return by the Return Room Interiors node","title":"return interiors"},{"location":"pipeline-nodes/return-interiors/#return-interiors","text":"This node provides an alternative way to apply calculated rooms interiors. Use it if you want to make your pipeline structure cleaner. Inputs: Room Interiors - Room Interiors which you want to return to the End node","title":"Return Interiors"},{"location":"pipeline-nodes/return-interiors/#examples","text":"These two methods give the same result. Return by the End node Return by the Return Room Interiors node","title":"Examples"},{"location":"pipeline-nodes/return-skins-layer/","text":"Return Skins Layer \u00b6 This node provides an alternative way to apply a skins layer. Use it if you want to make your pipeline structure cleaner. Inputs: Skins Layer - a skins layer that you want to return to the End node. Examples \u00b6 These two methods give the same result. Return by the End node Return by the Return Skins Layer node","title":"return skins layer"},{"location":"pipeline-nodes/return-skins-layer/#return-skins-layer","text":"This node provides an alternative way to apply a skins layer. Use it if you want to make your pipeline structure cleaner. Inputs: Skins Layer - a skins layer that you want to return to the End node.","title":"Return Skins Layer"},{"location":"pipeline-nodes/return-skins-layer/#examples","text":"These two methods give the same result. Return by the End node Return by the Return Skins Layer node","title":"Examples"},{"location":"pipeline-nodes/shift/","text":"Shift \u00b6 This node shifts input cells Inputs: In - cells to shift Outputs: Out - result of shifting Properties: X - X axis offset Y - Y axis offset Floor - floor offset Examples \u00b6 In this example we'll shift a right side of the house. At first we have to filter a right side of the house. Now we can shift it. Let'd apply changes by the Override node. A very strange result, isn't it? That's because the process of overriding works with positions, not with cell id, so, from the perspective of the overriding node, we created some bunch of cells somewhere outside of the house and now trying to add them to the house. So, it just doing it. To solve this problem we have to just exclude cells which we want to shift.","title":"shift"},{"location":"pipeline-nodes/shift/#shift","text":"This node shifts input cells Inputs: In - cells to shift Outputs: Out - result of shifting Properties: X - X axis offset Y - Y axis offset Floor - floor offset","title":"Shift"},{"location":"pipeline-nodes/shift/#examples","text":"In this example we'll shift a right side of the house. At first we have to filter a right side of the house. Now we can shift it. Let'd apply changes by the Override node. A very strange result, isn't it? That's because the process of overriding works with positions, not with cell id, so, from the perspective of the overriding node, we created some bunch of cells somewhere outside of the house and now trying to add them to the house. So, it just doing it. To solve this problem we have to just exclude cells which we want to shift.","title":"Examples"},{"location":"pipeline-nodes/shuffle/","text":"Shuffle \u00b6 This node shuffles an order of cells in the flow. Pretty useful if you want to add more random. Inputs: In - cells to shuffle Outputs: Out - result Examples \u00b6 Input is a house that has been completed. Let's filter random cells. If we want to filter another 30 cells, we can shuffle input cells by the Shuffle node.","title":"shuffle"},{"location":"pipeline-nodes/shuffle/#shuffle","text":"This node shuffles an order of cells in the flow. Pretty useful if you want to add more random. Inputs: In - cells to shuffle Outputs: Out - result","title":"Shuffle"},{"location":"pipeline-nodes/shuffle/#examples","text":"Input is a house that has been completed. Let's filter random cells. If we want to filter another 30 cells, we can shuffle input cells by the Shuffle node.","title":"Examples"},{"location":"pipeline-nodes/split-into-rooms/","text":"Split Into Rooms \u00b6 This node splits input cells to rooms. Every cell has its own RoomId, by default it's zero. Splitting By Rooms node splits cells by setting new RoomId to them, so, after this process, you can work with borders of cells by filtering them with a Mask. Inputs: In - cells to split Outputs: Out - result of splitting. Properties: Min Size - minimum side length of rooms Max Size - maximum side length of rooms Examples \u00b6 In this example we'll split floors into rooms, find relative interiors to them and place furniture. First we have to add floor and ceiling to all cells. Now let's try to split it into rooms And... Nothing happened! That's because the Split Into Rooms node just sets a RoomID to all cells, to actually split this house into rooms we should add walls in borders of rooms. Let's do it. Yay! It works! But that will happen if we'll try to do it without splitting into rooms? Well... One big room, as expected. Now let's add doors, interiors and furniture! !Note: It's better to add doors and windows before interiors and furniture because interiors calculating and furniture placing are sensitive for doors and windows. Next we have to calculate and apply interiors. Finish: add furniture.","title":"split into rooms"},{"location":"pipeline-nodes/split-into-rooms/#split-into-rooms","text":"This node splits input cells to rooms. Every cell has its own RoomId, by default it's zero. Splitting By Rooms node splits cells by setting new RoomId to them, so, after this process, you can work with borders of cells by filtering them with a Mask. Inputs: In - cells to split Outputs: Out - result of splitting. Properties: Min Size - minimum side length of rooms Max Size - maximum side length of rooms","title":"Split Into Rooms"},{"location":"pipeline-nodes/split-into-rooms/#examples","text":"In this example we'll split floors into rooms, find relative interiors to them and place furniture. First we have to add floor and ceiling to all cells. Now let's try to split it into rooms And... Nothing happened! That's because the Split Into Rooms node just sets a RoomID to all cells, to actually split this house into rooms we should add walls in borders of rooms. Let's do it. Yay! It works! But that will happen if we'll try to do it without splitting into rooms? Well... One big room, as expected. Now let's add doors, interiors and furniture! !Note: It's better to add doors and windows before interiors and furniture because interiors calculating and furniture placing are sensitive for doors and windows. Next we have to calculate and apply interiors. Finish: add furniture.","title":"Examples"},{"location":"pipeline-nodes/start/","text":"Start \u00b6 This is an enter point to the generation process. Data from the House Generator component uses to create a bunch of start cells, so, if you want to add more floors to the generation process, you have to add them to the House Generator component and so on. Outputs: Cells - cells constructed from a data from the House Generator component. Examples \u00b6 In this example we created a base cells with a size data from the House Generator component and added a Venus part to them.","title":"start"},{"location":"pipeline-nodes/start/#start","text":"This is an enter point to the generation process. Data from the House Generator component uses to create a bunch of start cells, so, if you want to add more floors to the generation process, you have to add them to the House Generator component and so on. Outputs: Cells - cells constructed from a data from the House Generator component.","title":"Start"},{"location":"pipeline-nodes/start/#examples","text":"In this example we created a base cells with a size data from the House Generator component and added a Venus part to them.","title":"Examples"}]}